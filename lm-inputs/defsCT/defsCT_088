Definition 4.2. For a finite category $A$, the similarity matrix $\zeta_{A}$ of $A$ is defined by $\zeta_{A}:A_{0}\times A_{0}\to\mathbb{Q}$ such that $\zeta_{A}(i,j)$ is the cardinal of the set $A(i,j)$ of morphisms. We say that $A$ admits Euler characteristic if $\zeta_{A}$ does, and then define the Euler characteristic $\chi(A)$ as $|\zeta_{A}|$.
Definition 2.30. A model structure on a category $M$ consists of three distinguished classes of morphisms $W$, $C$, and $F$ closed under retracts and compositions called weak equivalences, cofibrations, and fibrations satisfying the following properties. 1. If $f$ and $g$ are morphisms of $M$ such that $g\circ f$ is defined, two of $f,g$ and $g\circ f$ are weak equivalences, then so is the third. 2. Every morphism in $W\cap C$ has the right lifting property for $F$, and every morphism in $C$ has the right lifting property for $W\cap F$. 3. For any morphism $f$ in $M$ can be factored as $p\circ i$ by $p\in F\cap W$ and $i\in C$, and also $f$ can be factored as $q\circ j$ by $q\in F$ and $j\in C\cap W$. A morphism in $W\cap C$ is called a trivial cofibration, and a morphism in $W\cap F$ is called a trivial fibration, respectively. A model category is a category $M$ closed under small limits and colimits together with a model structure on $M$.
Definition 4.14. Let $X:\mathcal{A}\to\mathbf{BiCat}_{tri}$ be a trihomomorphism. The Grothendieck construction $\mathrm{Gr}(X)$ is a bicategory consisting of 1. $\mathrm{Gr}(X)_{0}=\{(a,x)\mid a\in\mathcal{A}_{0},x\in(Xa)_{0}\}$, 2. $\mathrm{Gr}(X)((a,x)(b,y))=\{(f,w)\mid f\in\mathcal{A}(a,b)_{0},w\in Xb(Xfx,y)\}$, 3. $\mathrm{Gr}(X)((a,x)(b,y))((f,w)(g,u))=\{(\alpha,\beta)\mid\alpha\in\mathcal{A% }(a,b)(f,g),\beta\in Xb(Xfx,y)(u\circ(X\alpha)_{x},w)\}$, with the canonical composition.
Definition 2.1. A small category $A$ consists of the following data; 1. a set of objects $A_{0}$, 2. a set of morphisms $A(x,y)$ for each $x,y\in A_{0}$, 3. a map $\circ:A(y,z)\times A(x,y)\to A(x,z)$ called the composition for each $x,y,z\in A_{0}$ satisfying associativity and identity conditions. Sometimes we denote $g\circ f$ simply by $gf$. A morphism $f\in A(x,y)$ is called invertible or an isomorphism if there exists an inverse $g\in A(y,x)$ such that $gf=1_{x}$ and $fg=1_{y}$. A category $A$ is called a groupoid when every morphism is invertible. A functor $f:A\to B$ between small categories $A$ and $B$ consists of a map $f:A_{0}\to B_{0}$ on objects and a map $f_{x,y}:A(x,y)\to B(fx,fy)$ on morphisms for each $x,y\in A_{0}$ preserving composition and identities. Let $\mathbf{Cat}$ denote the category of small categories and functors.
Definition 3.12. A strict homomorphism $f:\mathcal{A}\to\mathcal{B}$ is called a fibered in bigroupoids if it has the right lifting property in $\mathbf{BiCat}_{s}$ for $J^{{}^{\prime}}=\{F(*)\to F\Sigma[0],F\mathcal{L}\to[[2]],\mathcal{C}_{3}\to% \mathcal{C}_{2},\mathcal{C}_{1}\to\mathcal{C}_{2}\},$ introduced in Section 3.1 and Section 2.2. On the other hand, $f:\mathcal{A}\to\mathcal{B}$ is called a cofibered (resp. opfibered, coopfibered) in bigroupoids if it has the right lifting property in $\mathbf{BiCat}_{s}$ for the set $J^{\mathrm{co}}$ (resp. $J^{\mathrm{op}}$, $J^{\mathrm{coop}}$) consisting of the above opposite morphisms with respect to 1-morphisms (resp. 2-morphism, both 1-morphisms and 2-morphisms).
Definition 2.11 (Geometric nerve). Let $\mathcal{A}$ be a bicategory. A simplicial set $N(\mathcal{A})$ is given by the set of lax functors from $[n]$ to $\mathcal{A}$ as $N_{n}(\mathcal{A})$. This is called the geometric nerve, or simply the nerve of $\mathcal{A}$. The classifying space $B\mathcal{A}$ of a bicategory $\mathcal{A}$ is defined as the geometric realization of the nerve $N\mathcal{A}$.
Definition 3.7. Let $K$ be the set of 2-functors consisting of two inclusions; $k_{1}:SF\Sigma[0]\to S\mathcal{H}$ and $k_{2}:SF\Sigma[1]\to SF\Sigma S^{\infty}$.
Definition 2.17. For a simplicial set $X$, defined $W_{ps}(X)$ as a pseudogroupoid whose underlying category is the reduced Moore category $\widetilde{M}(|X|^{(1)},|X|^{0})$ for the pair of 1-skeleton and 0-skeleton of the geometric realization $|X|$ of $X$, and 2-morphisms are homotopy classes of homotopies of Moore paths in $|X|$. We call $W_{ps}(X)$ the Whitehead pseudogroupoid of $X$.
Definition 4.1. For finite sets $I$ and $J$, an $I\times J$ matrix is a function $I\times J\to\mathbb{Q}$. For an $I\times J$ matrix $\zeta$ and a $J\times H$ matrix $\eta$, the $I\times H$ matrix $\zeta\eta$ is defined by $\zeta\eta(i,h)=\sum_{j}\zeta(i,j)\eta(j,h)$ for each $i\in I$ and $h\in H$. An $I\times J$ matrix $\zeta$ has a $J\times I$ transpose $\zeta^{\mathrm{op}}$. Given a finite set $I$, we write $u_{I}:I\to\mathbb{Q}$ (or simply $u$) for the column vector with $u_{I}(i)=1$ for all $i$ in $I$. Let $\zeta$ be an $I\times J$ matrix. A weighting on $\zeta$ is a column vector $k^{*}:J\to\mathbb{Q}$ such that $\zeta k^{*}=u_{I}$. A coweighting on $\zeta$ is a row vector $k_{*}:I\to\mathbb{Q}$ such that $k_{*}\zeta=u^{\mathrm{op}}_{J}$. The matrix $\zeta$ admits Euler characteristic if it has a weighting and a coweighting. Then, its Euler characteristic is defined as $|\zeta|=\sum_{j}k^{j}=\sum_{i}k_{i}\in\mathbb{Q}.$ Note that this definition does not depend on the choice of a weighting and a coweighting.
Definition 2.2. A bicategory $\mathcal{A}$ consists of the following data; 1. a set of objects $\mathcal{A}_{0}$, 2. a (small) category of morphisms $\mathcal{A}(x,y)$ for each $x,y\in\mathcal{A}_{0}$, 3. a functor $\mathcal{A}(y,z)\times\mathcal{A}(y,x)\to\mathcal{A}(x,z)$ for each $x,y,z\in\mathcal{A}_{0}$, 4. an associator $\alpha_{hgf}:h(gf)\cong(hg)f$ for each composable triple $(h,g,f)\in\mathcal{A}(z,w)_{0}\times\mathcal{A}(y,z)_{0}\times\mathcal{A}(x,y)% _{0}$ and an unitor $\eta_{k}:1_{y}k\cong k$, $\theta_{k}:k1_{x}\cong k$ for each $k\in\mathcal{A}(x,y)_{0}$ satisfying the coherent condition. An element of $\mathcal{A}(x,y)_{0}$ is called a 1-morphism for $x,y\in\mathcal{A}_{0}$ and denote by a single arrow $x\to y$, and an element of $\mathcal{A}(x,y)(f,g)$ is called a 2-morphism and denote by a double arrow $f\Rightarrow g$. Therefore, a bicategory $\mathcal{A}$ is equipped with three kind of compositions, the composition of 1-morphisms $\mathcal{A}(y,z)_{0}\times\mathcal{A}(x,y)_{0}\to\mathcal{A}(x,z)_{0}$, the vertical composition of 2-morphisms $\mathcal{A}(x,y)(g,h)\times\mathcal{A}(x,y)(f,g)\to\mathcal{A}(x,y)(f,h)$, and the horizontal composition of 2-morphisms $\mathcal{A}(y,z)(h,i)\times\mathcal{A}(x,y)(f,g)\to\mathcal{A}(x,z)(hf,ig)$. In particular, a bicategory $\mathcal{A}$ is called a 2-category when each associator and unitor is an identity map. A 1-morphism $f\in\mathcal{A}(x,y)_{0}$ in a bicategory $\mathcal{A}$ is called an equivalence if there exists a 1-morphism $g\in\mathcal{A}(y,x)_{0}$ such that $gf\cong 1_{x}$ and $fg\cong 1_{y}$. A bigroupoid is a bicategory in which each 1-morphism is an equivalence and each 2-morphism is invertible, in particular, when a bigroupoid is also a 2-category, we call it pseudogroupoid. A 2-groupoid is a 2-category in which each 1-morphism and 2-morphism is invertible.
Definition 4.13. Let $\mathcal{A}$ be a bicategory and $\mathbf{BiCat}_{tri}$ be the tricategory consisting of bicategories, homomorphisms, lax natural transformations, and modifications. A trihomomorphism $X:\mathcal{A}\to\mathbf{BiCat}_{tri}$ consists of the following data; 1. a bicategory $Xa$ for each $a\in\mathcal{A}_{0}$, 2. a pseudo functor $\mathcal{A}(a,b)\to\mathbf{BiCat}_{tri}(Xa,Xb)$ for each $a,b\in\mathcal{A}_{0}$, satisfying the coherent conditions.
Definition 2.19. Let $\mathcal{G}$ be a 2-groupoid. • The set $\pi_{0}(\mathcal{G})$ of connected components of $\mathcal{G}$ consists of the isomorphism classes of objects. • The fundamental group $\pi_{1}(\mathcal{G},x)$ of $G$ with an object $x\in G_{0}$ is defined as the set of connected components $\pi_{0}(\mathcal{G}(x,x))$. • For an object $x\in\mathcal{G}_{0}$, define $\pi_{2}(\mathcal{G},x)$ as the group of natural transformations from the identity morphism on $x$ to itself.
Definition 2.5 (Pseudonatural transformation and modification). Let $f,g:\mathcal{A}\to\mathcal{B}$ be lax functors between bicategories $\mathcal{A}$ and $\mathcal{B}$. A lax natural transformation $\alpha:f\Rightarrow g$ consists of the following data; 1. a 1-morphism $\alpha_{x}:f(x)\to g(x)$ for each $x\in\mathcal{A}_{0}$, 2. a 2-morphism $\alpha_{w}:\alpha_{y}\circ f(w)\Rightarrow g(w)\circ\alpha_{x}$ for each 1-morphism $w:x\to y$ in $\mathcal{A}$, satisfying the coherent condition. A lax natural transformation $\alpha$ is called a pseudonatural transformation if each $\alpha_{w}$ is invertible. Let $\alpha,\beta:f\Rightarrow g$ be lax natural transformations between 2-functors $f,g:\mathcal{A}\to\mathcal{B}$. A modification $m:\alpha\Rrightarrow\beta$ consists of a 2-morphism $m_{x}:\alpha_{x}\Rightarrow\beta_{x}$ for each $x\in\mathcal{A}_{0}$ satisfying the coherent condition. For two 2-categories $\mathcal{A}$ and $\mathcal{B}$, the 2-category of internal hom $[\mathcal{A},\mathcal{B}]$ consists of 2-functors, pseudonatural transformations, and modifications. Similarly, we can define the internal hom in the category of pseudogroupoids, and 2-groupoids.
Definition 2.15. Let $f:\mathcal{A}\to\mathcal{B}$ be a homomorphism between bicategories $\mathcal{A}$ and $\mathcal{B}$. 1. $f$ is called biessentially surjective on objects if for any object $b\in\mathcal{B}_{0}$, there exists $a\in\mathcal{A}_{0}$ and an equivalence $f(a)\simeq b$ in $\mathcal{B}$. 2. $f$ is called a locally equivalence if the functor on the categories of morphisms $\mathcal{A}(x,y)\to\mathcal{B}(fx,fy)$ is an equivalence of small categories. 3. $f$ is called a biequivalence if it is biessentially surjective on objects and a locally equivalence.
Definition 4.9. Let $\mathcal{A}$ be a finite $\mathbf{Cat}$-graph, i.e. each set of objects, 1-morphisms, and 2-morphisms is finite. We call that $\mathcal{A}$ admits Euler characteristic if every category of morphism $\mathcal{A}(x,y)$ admits Euler characteristic for $x,y\in\mathcal{A}_{0}$, and also the similarity matrix $\zeta_{\mathcal{A}}:\mathcal{A}_{0}\times\mathcal{A}_{0}\to\mathbb{Q}$ given by $\zeta_{\mathcal{A}}(x,y)=\chi(\mathcal{A}(x,y))$ admits Euler characteristic. Then, we define the Euler characteristic $\chi(\mathcal{A})$ as $|\zeta_{\mathcal{A}}|$. If $\mathcal{A}$ is a finite bicategory, we say that $\mathcal{A}$ admits Euler characteristic if its underlying $\mathbf{Cat}$-graph does, and then we define $\chi(\mathcal{A})$ as that of the underlying $\mathbf{Cat}$-graph.
Definition 2.31 ([Hov99], [Hir03]). We say that a model category $M$ is cofibrantly generated if there exist sets $I$ and $J$ of morphisms such that 1. both $I$ and $J$ permit the small object argument, 2. $W\cap F=I\textrm{-inj}$ and $F=J\textrm{-inj}$. The above set $I$ is called a generating cofibrations, and $J$ is called a generating trivial cofibrations.
Definition 3.1. A homotopy adjunction between simplicial categories $\mathbf{C}$ and $\mathbf{D}$ is a pair of simplicial functors $L\colon\mathbf{C}\leftrightarrow\mathbf{D}\colon R$ together with an equivalence $\mathbf{D}(Lc,d)\simeq\mathbf{C}(c,Rd)$ of functors $\mathbf{C}^{\mathrm{op}}\times\mathbf{D}\to\mathbf{S}$.
Definition 6.1. Let $\mathbf{B}$ be a simplicial category. A left Bousfield localization of $\mathbf{B}$ is a simplicial category $\mathbf{L}$ together with a homotopy adjunction (Definition 3.1) $I\colon\mathbf{B}\longleftrightarrow\mathbf{L}\colon J,$ with $I$ the left adjoint, such that the right adjoint $J$ is homotopically full and faithful (Definition 4.1).
Definition 7.2. Let $\Theta$ be an algebraic theory. The category $\operatorname{Alg}_{\Delta}^{\mathrm{h}}(\Theta)$ is the localization $\operatorname{Alg}_{\Delta}^{\mathrm{h}}(\Theta)=F^{-1}\operatorname{Pre}_{% \Delta}(\Theta)$ of the category of simplicial presheaves with respect to the set $F$ of morphisms $f_{n}$ as in (7.1). Its fibrant objects will be referred to as homotopy $\Theta$-algebras.
Definition 4.1. A simplicial functor $F\colon\mathbf{D}\to\mathbf{T}$ is called homotopically full and faithful, if the induced maps $\mathbf{D}(x,y)\to\mathbf{T}(Fx,Fy)$ are equivalences for all $x$ and $y$.
Definition 4.6. A simplicial functor $F\colon\mathbf{C}\to\mathbf{M}^{\mathrm{fc}}$ is homotopically dense if there exists an equivalence $\operatorname{Id}_{\mathbf{M}^{\mathrm{fc}}}\simeq\operatorname{LKan}^{\mathrm% {h}}_{F}F$ as functors $\mathbf{M}^{\mathrm{fc}}\to\mathbf{M}^{\mathrm{fc}}$.
Definition 2.1. We say that epimorphisms in a category $\mathcal{B}$ are left-cancellable with respect to $\mathcal{M}$ provided that $q\in\mbox{Epi}(\mathcal{B})$ whenever $p\cdot q\in\mbox{Epi}(\mathcal{B})$ with $p,q\in\mathcal{M}$.
Definition 1.2. Assume that ${\mathcal{D}}$ is $\operatorname{Ext}$-finite, i.e. $\sum_{n}\dim\operatorname{Hom}(A,B[n])<\infty$ for all $A,B\in{\mathcal{D}}$. Then ${\mathcal{D}}$ is (right) saturated if every contravariant cohomological functor of finite type $H:{\mathcal{D}}\rightarrow\operatorname{Vect}(k)$ is representable.
Definition 2.2.3. We say that ${\mathcal{E}}$ strongly generates ${\mathcal{D}}$ if ${\mathcal{D}}=\langle{\mathcal{E}}\rangle_{k}$, for some $k$. We say that ${\mathcal{D}}$ is strongly finitely generated if it is strongly generated by one object.
Definition 2.3.1. Assume that $H:{\mathcal{D}}\rightarrow\operatorname{Ab}$ is a contravariant cohomological functor. Then an $n$-resolution of $H$ with respect to ${\mathcal{E}}$ is a directed system of objects $(A_{i})_{i>0}$ together with compatible natural transformations $\zeta_{i}:h_{A_{i}}\rightarrow H$ such that for any $E\in{\mathcal{E}}$, $p\in{\mathbb{Z}}$, $\zeta_{i}(E[p])$ is surjective and $\operatorname{ker}(\zeta_{i}(E[p]))_{i}$ is of order $n$. A resolution of $H$ is a $1$-resolution.
Definition 3.2. Let $\mathcal{C}$ and $\mathcal{D}$ be two simplicial model categories and $F\in Fun(\mathcal{C},\mathcal{D})$. Let J be a small subcategory of Cat which does not contain the empty category. $P_{n,{\bf J}}F$ is referred to as the $n$-th Taylor polynomial of $F$ with respect to J, and $...\rightarrow P_{n,{\bf J}}F\overset{q_{n}F}{\rightarrow}P_{n-1,{\bf J}}F% \overset{q_{n-1}F}{\rightarrow}...\rightarrow P_{1,{\bf J}}F\overset{q_{1}F}{% \rightarrow}P_{0,{\bf J}}F$ as the Taylor tower of $F$ with respect to J. We write it as $\{P_{n,{\bf J}}F\}$. When J consists of the terminal category only, $P_{n,\ast}F$ is referred to as the $n$-th Taylor polynomial of $F$ and written $P_{n}F$. The Taylor tower of $F$ with respect to $\ast$ is written $\{P_{n}F\}$.
Definition 6.1. Let $\mathcal{C}$ be a simplicial model category and $J$ a small category. An object $\mathcal{X}$ of $\mathcal{C}^{J_{+}}$ is homotopy Cartesian if the natural map $\mathcal{X}(\emptyset)\rightarrow cholim_{J}\mathcal{X}$ is a weak equivalence.
Definition 2.8. Let $\mathcal{C}$ be a category with duality over $k$. The Frobenius–Schur indicator (or FS indicator, for short) of $X\in\mathcal{C}$ is defined and denoted by $\nu(X)=\operatorname{Tr}(\mathsf{T}_{X,X})$, where $\operatorname{Tr}$ means the trace of a linear map.
Definition 3.1. A pivotal algebra is a triple $(A,S,g)$ consisting of an algebra $A$, an anti-algebra map $S:A\to A$, and an invertible element $g\in A$ satisfying $S(g)=g^{-1}$ and $S^{2}(a)=gag^{-1}$ for all $a\in A$.
Definition 4.1. A copivotal coalgebra is a triple $(C,S,\gamma)$ consisting of a coalgebra $C$, an anti-coalgebra map $S:C\to C$ and a linear map $\gamma:C\to k$ satisfying $S^{2}(c)=\langle\gamma,c_{(1)}\rangle c_{(2)}\langle\overline{\gamma},c_{(3)}% \rangle\text{\quad and \quad}\overline{\gamma}=\gamma\circ S$ for all $c\in C$, where $\overline{\gamma}:C\to k$ is the inverse of $\gamma$ with respect to $\star$.
Definition 2.17. Let $\mathcal{C}$ be a category with duality over $k$, and let $\mathbf{t}$ be a $k$-linear twisting adjunction for $\mathcal{C}$. The ($\mathbf{t}$-)twisted FS indicator $\nu^{\mathbf{t}}(X)$ of $X\in\mathcal{C}$ is defined by $\nu^{\mathbf{t}}(X)=\nu(X^{\mathbf{t}})$ where $X^{\mathbf{t}}\in\mathcal{C}^{\mathbf{t}}$ is the object $X$ regarded as an object of $\mathcal{C}^{\mathbf{t}}$.
Definition 2.4. Let $\mathcal{C}$ and $\mathcal{D}$ be categories with duality. A duality preserving functor from $\mathcal{C}$ to $\mathcal{D}$ is a pair $(F,\xi)$ consisting of a functor $F:\mathcal{C}\to\mathcal{D}$ and a natural transformation $\xi:F(X^{\vee})\to F(X)^{\vee}$ ($X\in\mathcal{C}$) making $\begin{CD}F(X)@>{F(j_{X})}>{}>F(X^{\vee\vee})\\ @V{j_{F(X)}}V{}V@V{}V{\xi_{X^{\vee}}}V\\ F(X)^{\vee\vee}@>{}>{\xi_{X}^{\vee}}>F(X^{\vee})^{\vee}\end{CD}$ commute for all $X\in\mathcal{C}$. If, moreover, $\xi$ is an isomorphism, then $(F,\xi)$ is said to be a strong. If $\xi$ is the identity, then $(F,\xi)$ is said to be strict. Now let $(F,\xi),(G,\zeta):\mathcal{C}\to\mathcal{D}$ be such functors. A morphism of duality preserving functors from $(F,\xi)$ to $(G,\zeta)$ is a natural transformation $h:F\to G$ making $\begin{CD}F(X^{\vee})@>{\xi_{X}}>{}>F(X)^{\vee}\\ @V{h_{X^{\vee}}}V{}V@A{}A{h_{X}^{\vee}}A\\ G(X^{\vee})@>{}>{\zeta_{X}}>G(X)^{\vee}\end{CD}$ commute for all $X\in\mathcal{C}$.
Definition 2.16. An involution of $\mathcal{C}$ is a triple $\mathbf{t}=(F,\xi,\eta)$ such that $(F,\xi)$ is a strong duality preserving functor on $\mathcal{C}$ and $\eta$ is an isomorphism $\eta:(\mathsf{id}_{\mathcal{C}},\mathsf{id}_{(-)^{\vee}})\to(F,\xi)\circ(F,\xi)$ of duality preserving functors satisfying $\eta_{F(X)}=F(\eta_{X})$ for all $X\in\mathcal{C}$. We say that $\mathbf{t}$ is strict if $\xi$ and $\eta$ are identities.
Definition 2.1. A category with duality is a triple $\mathcal{C}=(\mathcal{C},(-)^{\vee},j)$ consisting of a category $\mathcal{C}$, a contravariant functor $(-)^{\vee}:\mathcal{C}\to\mathcal{C}$ and a natural transformation $j:\mathsf{id}_{\mathcal{C}}\to(-)^{\vee\vee}$ satisfying $(j_{X})^{\vee}\circ j_{X^{\vee}}=\mathsf{id}_{X^{\vee}}$ for all $X\in\mathcal{C}$. If, moreover, $j$ is a natural isomorphism, then we say that $\mathcal{C}$ is a category with strong duality, or, simply, $\mathcal{C}$ is strong.
Definition 2.7. By a category with duality over $k$, we mean a $k$-linear category with duality whose duality functor is $k$-linear.
Definition 2.23. Let $\mathcal{C}$ be a $k$-linear pivotal monoidal category satisfying (2.12) and suppose that an action of $G$ on $\mathcal{C}$ is given. For a positive integer $n$ and an element $g\in G$, we define the $g$-twisted $n$-th FS indicator $\nu_{n}^{g}(V)$ of $V\in\mathcal{C}$ by $\nu_{n}^{g}(V)=\nu_{n}((V,g))$, where $\nu_{n}$ in the right-hand side stands for the $n$-th FS indicator of Ng and Schauenburg [34] for the $k$-linear pivotal monoidal category $\mathcal{C}\rtimes G$.
Definition 2.2. Let $\varphi\colon\mathcal{D}\to\mathcal{D}^{\prime}$ be an exact functor between $\mathbf{k}$-linear, triangulated categories. Then $\varphi$ is said to be fully faithful: if the maps $\operatorname{Hom}_{\mathcal{D}}(D_{1},D_{2})\text{{ \raisebox{3.44pt}{${% \scriptscriptstyle\sim}$}}}\hskip-6.5pt{\rightarrow}\hskip 3.0pt\operatorname{% Hom}_{\mathcal{D}^{\prime}}(\varphi(D_{1}),\varphi(D_{2}))$ induced by $\varphi$ are isomorphisms for all $D_{1},D_{2}\in\mathcal{D}$. conservative: if $f$ is a morphism in $\mathcal{D}$ such that $\varphi(f)$ an isomorphism, then $f$ is an isomorphism itself. essentially surjective: if for any object $D^{\prime}\in\mathcal{D}^{\prime}$, there is an object $D\in\mathcal{D}$ such that $\varphi(D)\cong D^{\prime}$. an equivalence: (or invertible) if $\varphi$ is fully faithful and essentially surjective. piecewise invertible: if there are weak semi-orthogonal decompositions $\mathcal{D}={\langle\mathcal{D}_{1},\ldots,\mathcal{D}_{n}\rangle}$, $\mathcal{D}^{\prime}={\langle\mathcal{D}^{\prime}_{1},\ldots,\mathcal{D}^{% \prime}_{n}\rangle}$ such that $\varphi(\mathcal{D}_{i})\subseteq\mathcal{D}^{\prime}_{i}$ and $\varphi|_{\mathcal{D}_{i}}$ induces an equivalence $\mathcal{D}_{i}\text{{ \raisebox{3.44pt}{${\scriptscriptstyle\sim}$}}}\hskip-% 6.5pt{\rightarrow}\hskip 3.0pt\mathcal{D}^{\prime}_{i}$.
Definition 3.1 A data service in a strict symmetric monoidal category $({\cal C},\otimes,I)$ is a quadruple $(A,{\scriptstyle\top},\delta,\varrho)$ where • $A\in\lvert{\cal C}\rvert$ is the underlying data type, • ${\scriptstyle\top}:A\rightarrow I$ is the deleting operation, • $\delta:A\rightarrow A\otimes A$ is the copying operation – such that $A\otimes A\xleftarrow{\delta}A\xrightarrow{{\scriptstyle\top}}I$ is a commutative monoid, • $\varrho:A\otimes A\rightarrow A$ is the filtering operation – which makes $A$ into a commutative semigroup. The copying and filtering operations are furthermore required to satisfy the data distribution conditions $(A\otimes\varrho)\circ(\delta\otimes A)\ =\ \delta\circ\varrho\ =\ (\varrho% \otimes A)\circ(A\otimes\delta)\qquad\qquad\quad\varrho\circ\delta={\rm id}$ $\varrho$$\delta$$\varrho$$\delta$= $\varrho$$\delta$= $\varrho$$\delta$= Main examples and explanations Cartesian services? The simplest examples of the copying and the deleting operations are given by the cartesian structure, say in the category ${\sf Set}$ of sets and functions, where $\otimes$ is the cartesian product $\times$, and $\lozenge:A\rightarrow A\times A$ doubles each $a\in A$ into the pair $<a,a>\in A\times A$, whereas the unit $I$ is the terminal object $1\!\!1$, and $!:A\rightarrow 1\!\!1$ deletes all $a\in A$ by mapping them into the unique element $\emptyset\in 1\!\!1$. Indeed, it is easy to see that the monoidal structure of any given category is cartesian precisely when there are natural copying and deleting operations $(\delta,{\scriptstyle\top})$ on each of its objects. The naturality of the copying and the deleting operations just means that all morphisms preserve them, in the sense that $\delta_{B}\circ f=(f\otimes f)\circ\delta_{A}$ and ${\scriptstyle\top}_{B}\circ f={\scriptstyle\top}_{A}$ hold for all $A\xrightarrow{f}B$. In terms of Sec. 3.1.2, this means that all morphisms $f\in{\cal C}(A,B)$ are comonoid homomorphisms. Intuitively, these two preservation properties can be understood as telling that $f$ is single-valued, and that it is total. This is exactly what they mean in the category ${\sf Rel}$ of sets and relations. Adding a data filtering operation $\varrho$ destroys the cartesian structure, because the requirement that $A\otimes A\xrightarrow{\varrho}A$ is a comonoid homomorphism, together with the Frobenius condition, implies that $A$ must be trivial. For this reason, the cartesian structure does not provide a full data service. Partial functions. A simple example of full data services can be found in the category ${\sf Pfn}$ of sets and partial functions, with the monoidal structure induced by the cartesian products of sets. This means that the copying and the deleting operations are as described above, but they do not form a cartesian structure with respect to partial functions, because the requirement ${\scriptstyle\top}_{B}\circ f={\scriptstyle\top}_{A}$ just says that the function $f$ must be total. The filtering operation $\varrho:A\otimes A\rightarrow A$ maps $<a,a>$ into $a$, and remains undefined on $<a,b>$ when $a\neq b$. What is the meaning of the data distribution conditions? The first equation in (10) is known as the Frobenius condition [7, 8]. It allows bringing any well typed expression formed of $\delta$s and $\varrho$s to a normal form, where all $\delta$s come after all $\varrho$s. Since the associativity laws make equal, on one hand, all different expressions $\Delta:A\rightarrow A^{\otimes n}$, for any fixed $n$, formed of $\delta$s alone, and on the other hand all different expressions $\nabla:A^{\otimes m}\rightarrow A$, for any fixed $m$, formed of $\varrho$s alone, the effect of these Frobenius normalizations is that any operation composed from $\delta$s and $\varrho$s boils down to a ”spider” in the form $A^{\otimes m}\xrightarrow{\nabla}A\xrightarrow{\Delta}A^{\otimes n}$, with $m$ legs coming in and $n$ legs coming out [12, 9]. The body of such a ”spider” is a data distribution point. If in a data service in the category ${\sf Pfn}$ of partial functions the same value enters a distribution point through all of the strings coming in, then this value will be distributed through all of the strings going out; otherwise, if some of the incoming values are not equal, then no value will come out. The second equation in (10) implies that the data that can be copied and deleted are normal, in the sense that will be spelled out in Prop. 3.10 below. Its logical meaning was analyzed in more detail in [15, Sec. 4.2]. Some other logical consequences of the Frobenius conditions, that will be used in the sequel of this work, were analyzed in [15, Sec. 4.1]. Relations. The category ${\sf Rel}$ of sets and binary relations, still with the monoidal structure induced by the cartesian products of sets, clearly contains all data services contained in its subcategory ${\sf Pfn}$. The difference is that the filtering operation $\varrho\in{\sf Rel}(A\times A,A)$ of any relational data service has a unit ${\scriptstyle\bot}\in{\sf Rel}(1\!\!1,A)$, and thus forms a monoid. This unit does not exist in ${\sf Pfn}$. For the data service induced on the set $A$ by the cartesian comonoid $A\times A\xleftarrow{\lozenge}A\xrightarrow{!}1\!\!1$, this unit is provided by the ”chaotic” relation ${\scriptstyle\bot}=!^{op}=\left\{<\emptyset,a>\ |\ a\in A\right\}$, which is obviously not a partial function. In general, it can be shown that a data service where the filtering operations form monoids must be self-dual. Indeed, a monoid and a comonoid connected by the Frobenius law form a Frobenius algebra, which is a self-dual structure [39]. Frobenius algebras have a rich mathematical theory, and their computational interpretations have been recently recognized in categorical quantum mechanics [8, 12, 15]. The Frobenius structure makes its carrier self-dual [15, Thm. 4.3], and a monoidal category where all objects are self-dual is compact [22]. Vector spaces. The set based examples of data services share an important property which is not always satisfied: namely that any element $a:I\rightarrow A$ can be copied by the copying operation, in the sense that $\delta\circ a=a\otimes a$. This is not true in general. To understand this, consider the category ${\sf Vec}$ of vector spaces and linear operators. A comonoid over a space $A$ can be defined by selecting an orthnormal basis ${{\sf Vec}}^{\flat}(A)$ for this space and by defining the linear operator $\delta\in{\sf Vec}(A,A\otimes A)$ by the matrix that sends the basis vectors $|b>\in{{\sf Vec}}^{\flat}(A)$ to the basis vectors $|bb>\in{{\sf Vec}}^{\flat}(A\otimes A)$. Remarkably, it turns out that every commutative Frobenius algebra over a vector space $A$ comes about in this way, i.e. that the vectors $\alpha\in A$ satisfying $\delta\otimes\alpha=\alpha\otimes\alpha$ form an orthogonal family which spans $A$, provided that $A$ is finitely dimensional [13]. Furthermore, dropping the unit ${\scriptstyle\bot}$ and relaxing the Frobenius monoid to a semigroup corresponds to dropping the finiteness requirement on the basis [1]. A basis of a vector space $A$ can thus be specified entirely in terms of linear operators — just by specifying a data service on it. Representing, copying and deleting data In a monoidal category ${\cal C}$, the data of type $A$ are presented as the morphisms $I\rightarrow A$, i.e. the elements of ${\cal C}(A)$. In ${\sf Pfn}$, the data values $a\in{\sf Pfn}(A)$ are thus the partial functions $1\!\!1\xrightarrow{a}A$, which are either the elements of the set $A$ in the usual sense, or the empty function $1\!\!1\xrightarrow{\emptyset}A$. In ${\sf Rel}$, the data values $a\in{\sf Rel}(A)$ are just the subsets of the set $A$. In ${\sf Vec}$ the data values $a\in{\sf Vec}(A)$ are the vectors in the vector space $A$. 3.3.1 Basic data A data value $a\in{\cal C}(A)$ can be copied by a data service $(A,{\scriptstyle\top},\delta,\varrho)$ if $\delta\circ a=a\otimes a$. It can be deleted if ${\scriptstyle\top}\circ a={\rm id}_{I}$. In terms of Sec. 3.1.2, this means that $a\in{\cal C}(A)$ can be copied and deleted if and only if the morphism $a:1\!\!1\rightarrow A$ is a homomorphism from the comonoid $I\otimes I\xleftarrow{=}I\xrightarrow{=}I$ to the comonoid $A\otimes A\xleftarrow{\delta}A\xrightarrow{{\scriptstyle\top}}I$. Definition 3.2 A basic data value, or an (abstract) element with respect to a data service $(A,{\scriptstyle\top},\delta,\varrho)$ is a data value $a\in{\cal C}(A)$ that can be copied and deleted: it corresponds to a comonoid homomorphism $a:I\rightarrow A$. ${{\cal C}}^{\flat}(A,{\scriptstyle\top},\delta,\varrho)$ denotes the set of basic data values with respect to the data service $(A,{\scriptstyle\top},\delta,\varrho)$ in ${\cal C}$. It is abbreviated to ${{\cal C}}^{\flat}(A)$ whenever the confusion is unlikely. This is the basis of ${\cal C}(A)$. The data values that are not basic are called mixed. 3.3.2 Examples We mentioned above that ${{\sf Vec}}^{\flat}(A,{\scriptstyle\top},\delta,\varrho)\subseteq{\sf Vec}(A)$ is a basis of the vector space $A$ uniquely determined by the given data service. The vectors in ${\sf Vec}(A)\setminus{{\sf Vec}}^{\flat}(A)$ are mixed, and cannot be copied and deleted. At the first sight, the situation in the set-based examples seems simpler: the cartesian data services $A\times A\underset{\lozenge^{o}}{\overset{\lozenge}{\leftrightarrows}}A% \xrightarrow{!}I$ allow copying all data $a\in{\sf Pfn}(A)$, and they allow deleting all data except $\emptyset\in{\sf Pfn}(A)$. Thus ${{\sf Pfn}}^{\flat}(A)=A$, and the abstract elements of a set $A$ defined in Def. 3.2 coincide with the usual elements of $A$. In ${\sf Rel}$, a subset $a\in{\sf Rel}(A)$ can be copied by the cartesian data service if and only if it has at most one element, and it can be deleted if and only if it has at least one element. So ${{\sf Rel}}^{\flat}(A,!,\lozenge,\lozenge^{o})=A$ again. However, besides these cartesian data services, the category ${\sf Rel}$ admits many nonstandard data services. This is a consequence of the fact that there are nonstandard commutative Frobenius algebras in ${\sf Rel}$, and we have explained above that such algebras are just data services where the filtering semigroup is a monoid. These nonstandard Frobenius algebras in ${\sf Rel}$ were analyzed in [32], where it has been shown that each commutative Frobenius algebra in ${\sf Rel}$ corresponds to a partition of $A$ into a disjoint union $A=\coprod_{j\in J}A_{j}$, where each $A_{j}$ carries the structure of an abelian group. The standard Frobenius algebras, induced by the cartesian structure, correspond to the special case where all parts $A_{j}$ are one element sets, with the trivial group structure. This analysis lifts from Frobenius algebras to data services, as it not depend on the units, as explained in [1]. A data service $A\otimes A\underset{\varrho}{\overset{\delta}{\leftrightarrows}}A\xrightarrow{% {\scriptstyle\top}}I$ in ${\sf Rel}$ thus corresponds to a partition of $A$ into abelian groups. It follows that every data service in ${\sf Rel}$ is a Frobenius algebra. The group structures over the disjoint parts $A_{j}\subseteq A$ can be conjoined into a monoid of relations over $A=\coprod_{j\in J}A_{j}$ in the form ${tensy\vbox{\hbox spread 0.0pt{\hbox{\kern 2.00016pt\hbox{$\displaystyle% \penalty 1A_{j}\times A_{j}\xrightarrow{+_{j}}A_{j}\xleftarrow{o_{j}}1\!\!1$}}% }\hbox{\hbox{\kern 0.0pt\vrule height 0.25pt depth 0.25pt width 96.665522pt% \hbox{\kern 3.0pt$(j\in J)$}}}\hbox{\kern 0.0pt\hbox{$\displaystyle A\ \times A% \ \xrightarrow{+\ }A\ \xleftarrow{o\ }1\!\!1$}}}}$ where $+$ is the partial function such that $a+b$ is defined to be $a+_{j}b$ if and only if $a,b\in A_{j}$ for some $j\in J$, otherwise undefined; and where $o$ is the multivalued relation, relating the unique element of $1\!\!1$ with $o_{j}\in A_{j}$ for all $j\in J$. In the corresponding data service $(A,{\scriptstyle\top},\delta,\varrho)$, the copying and deleting comonoid $A\times A\xleftarrow{\delta}A\xrightarrow{{\scriptstyle\top}}1\!\!1$ consists of the opposite relations of the filtering monoid $A\times A\xrightarrow{\varrho}A\xleftarrow{{\scriptstyle\bot}}1\!\!1$, which is just this abelian group structure, with $\varrho=+$ and ${\scriptstyle\bot}=o$. It is easy to see that a abstract element of $A$ must support this group structure, and that they are thus just the underlying sets of the partition, i.e. $\displaystyle{{\sf Rel}}^{\flat}(A)$ $\displaystyle=$ $\displaystyle\left\{A_{j}\subseteq A\ |\ j\in J\right\}$ All other subsets $a\subseteq A$ correspond to mixed data, which cannot be copied and deleted. This lifts an abstract version of the basis decomposition from vector spaces and linear operators to sets and relations, which turn out to support toy models of quantum computation [15]. In fact, a data service structure can even be viewed as a rudimentary Hilbert space structure, which will be useful in modeling randomized computation. 3.3.3 Functions and mixtures Definition 3.3 The pure morphisms, or (basic) functions with respect to data services $(A,{\scriptstyle\top}_{A},\delta_{A},\varrho_{A})$ and $(B,{\scriptstyle\top}_{B},\delta_{B},\varrho_{B})$ are the morphisms $f\in{\cal C}(A,B)$ that correspond to comonoid homomorphisms $f:A\rightarrow B$. The set of pure morphisms with respect the given data services on $A$ and $B$ are written ${{\cal C}}^{\flat}(A,B)$. This is the basis of ${\cal C}(A,B)$. The morphisms that are not pure are called mixed. Remark. The functions are obviously closed under composition, and they include identities, so they form a category. The category ${\cal C}_{\times}$ of comonoids in ${\cal C}$ and functions (comonoid homomorphisms) between them is the cofree cartesian category over ${\cal C}$, i.e. it comes with a functor ${\cal C}_{\times}\rightarrow{\cal C}$, forgetting the comonoid structure [16]. Explanation. A partial function in ${\sf Pfn}$ is pure if and only if it is total. A possible computational interpretation that will become clear in the sequel is that a function that is not total cannot be deleted by a data service, because it cannot decide whether this function will halt or not. A relation in ${\sf Rel}$ is pure with respect to the standard cartesian data services if and only if it is a function in the usual sense, i.e., it is a total and single-valued relation. The totality means that it preserves the cartesian comonoid unit; the single-valuedness means that it preserves the comonoid diagonal. A possible computational interpretation in terms of relations as the denotations of nondeterministic computations is that a data service cannot run in parallel several copies of a relation that is not single-valued, because the different copies of the same relation may make different nondeterministic choices at runtime. A linear operator $f\in{\sf Vec}(A,B)$ is pure with respect to the data services with the bases ${{\sf Vec}}^{\flat}(A)$ and ${{\sf Vec}}^{\flat}(B)$ if and only if it is induced by a function ${f}^{\flat}:{{\sf Vec}}^{\flat}(A)\rightarrow{{\sf Vec}}^{\flat}(B)$. Clearly, most linear operators are mixtures. The relational mixtures with respect to nonstandard data services will play an important role in the sequel. Proposition 3.4 Let $A$ and $B$ be data services in ${\sf Rel}$ induced by the abelian group decompostions $A=\coprod_{j\in J}A_{j}$ and $B=\coprod_{k\in K}B_{k}$. A relation $f\in{\sf Rel}(A,B)$ if and only if there is a function $\varphi:J\rightarrow K$ and $f$ decomposes into a disjoint union $f=\coprod_{j\in J}f_{j}$ where each $f_{j}\in{\sf Rel}\left(A_{j},B_{\varphi(j)}\right)$ is a chaotic relation with $af_{j}b$ for all $a\in A_{j}$ and all $b\in B_{\varphi(j)}$. Convolution, norm, inner product Definition 3.5 Any data service on $A$ induces the operations • convolution $\star\ :\ {\cal C}(A,B)\times{\cal C}(A,B)\longrightarrow{\cal C}(A,B)$ with $\displaystyle f\star g$ $\displaystyle=$ $\displaystyle\varrho_{B}\circ(f\otimes g)\circ\delta_{A}$ • norm $\lvert-\rvert\ :\ {\cal C}(A)\longrightarrow{\cal C}(I)$ with $\displaystyle\lvert a\rvert$ $\displaystyle=$ $\displaystyle{\scriptstyle\top}_{A}\circ a$ • inner product $<-|->\ :\ {\cal C}(A)\times{\cal C}(A)\longrightarrow{\cal C}(I)$ with $\displaystyle<a|b>$ $\displaystyle=$ $\displaystyle{\scriptstyle\top}_{A}\circ\varrho_{A}\circ(a\otimes b)$ $f$$g$$A$$B$ Figure 6: Convolution $a$\closepath\closepath Figure 7: Norm $a$$b$\closepath\closepath\closepath Figure 8: Inner product Examples. In ${\sf Vec}$, these operations take their usual meaning: the abstract inner product is the usual inner product, the norm is the $\ell_{1}$-norm, and the convolution of the matrices $f$ and $g$ is the entry-wise multiplication $(f\star g)_{i}=f_{i}\cdot g_{i}$, so that $<a|b>=\lvert a\star b\rvert$, where the convolution is taken for $A=I$. It is easy to see that this holds in general. In ${\sf Pfn}$, $f\star g=f\cap g$ is the intersection, so that $f\star f=f$ hods for all $f$. This is also true with respect to the standard, i.e. cartesian data services in ${\sf Rel}$. 3.4.1 Abstract relations Definition 3.6 A morphism $f\in{\cal C}(A,B)$ is an (abstract) relation with respect to some given data service on $A$ and $B$ if $f\star f=f$. Proposition 3.7 The convolution operation is always associative and commutative, and thus makes ${\cal C}(A,B)$ into a commutative semigroup relative to any given data services on $A$ and $B$. Abstract relations form a subsemilattice of each of these semigroups. Examples. All morphisms in ${\sf Pfn}$ are abstract relations. All morphisms in ${\sf Rel}$ are abstract relations with respect to the standard, cartesian data services. The situation is more interesting with respect to the nonstandard data services. Proposition 3.8 Let $A$ and $B$ be data services in ${\sf Rel}$ induced by the abelian group decompostions $A=\coprod_{j\in J}A_{j}$ and $B=\coprod_{k\in K}B_{k}$. Then $f\in{\sf Rel}(A,B)$ is an abstract relation with respect to the induced convolution operation $\star:{\sf Rel}(A,B)\times{\sf Rel}(A,B)\rightarrow{\sf Rel}(A,B)$ if and only if there is a partial bijection $\varphi:J\rightarrow K$ and $f$ decomposes into a disjoint union $f=\coprod_{j\in J}f_{j}$, where $f_{j}=\emptyset$ if $\varphi(j)$ is undefined, and otherwise $f_{j}\in{\sf Rel}\left(A_{j},B_{\varphi(j)}\right)$ is a congruence, in the sense that $ufx\wedge vfy\Longrightarrow(u+v)f(x+y)\wedge(-u)f(-x)$. More examples. Since the convolution in ${\sf Vec}$ is the entry-wise multiplication of the matrices, a linear operator $f\in{\sf Vec}(A,B)$ is an abstract relation with respect to the bases ${{\sf Vec}}^{\flat}(A)$ and ${{\sf Vec}}^{\flat}(B)$ if and only if the entries of its matrix representation are idempotent, i.e. they must all be 0s or 1s. While such matrices can be naturally viewed as binary relations between the basis elements, their matrix composition in ${\sf Vec}$ is not the usual relational composition. This shows that abstract relations are in general not closed under composition. This was discussed in [12]. Comment. Although providing some data services over all objects of ${\cal C}$ makes all of its hom-set ${\cal C}(A,B)$ into a semigroups, this structure is generally not preserved by the composition, and therefore it does not make ${\cal C}$ into a semigroup enriched category [21]. 3.4.2 Scalars As mentioned in Sec. 2, the ”elements” of the tensor unit $I$, i.e. the elements of the set ${\cal C}(I)={\cal C}(I,I)$ are called scalars. In general, the monoidal structure comes with an isomorphism $I\cong I\otimes I$, which provides $I$ with a canonical Frobenius algebra structure, and thus a data service and a convolution operation. In a strict monoidal category, these isomorphisms are identities, i.e. $I=I\otimes I$ holds on the nose. For the scalars $\alpha,\beta\in{\cal C}(I)$, the strictness assumption and the definition of the convolution together imply $\alpha\star\beta\ =\ \alpha\otimes\beta\ =\ \alpha\circ\beta$ Hence the commutative monoid $({\cal C}(I),\star,{\rm id}_{I})$. We usually elide its operation, and reduce all of the above expressions to $\alpha\beta$. 3.4.3 Bases are orthonormal Definition 3.9 A data value $a\in{\cal C}(A)$ is normal if $<a|a>={\rm id}_{I}$. Data values $a,b\in{\cal C}(A)$ are orthogonal if $<a|b>^{2}=<a|b>$. A set $S\subseteq{\cal C}(A)$ is orthonormal if all of its elements are normal and any pair is orthogonal. Proposition 3.10 The basis ${{\cal C}}^{\flat}(A)$ of any type $A$ is orthonormal. The proof is left as an easy exercise in diagrammatic reasoning. Monoidal computer The idea of a monoidal computer is that it should provide a data service ${\cal C}$ where all morphisms $f\in{\cal C}(A,B)$ are computable. One way to say that $f$ is computable is to require that that there is a program $p$ which encodes the computation $f$. Since a program needs to be manipulated, transformed and composed, it should be a basic data value, that can be copied and deleted. We thus require that for any pair of types $L,M$ in ${\cal C}$ there is a surjective ”program execution” operation $u:{{\cal C}}^{\flat}(\Xi)\twoheadrightarrow{\cal C}(L,M)$ that interprets the basic data values $p\in{{\cal C}}^{\flat}(\Xi)$ as programs and assigns to them the corresponding computations $u(p)\in{\cal C}(L,M)$. Definition 4.1 A (basic) monidal computer is a data service ${\cal C}$ which has: • a universal data type $\Xi$: it generates all types as its tensor powers, i.e. for every $M\in\lvert{\cal C}\rvert$ there is $m\geq 0$ such that $M=\Xi^{\otimes m}$ • universal evaluators $u^{M}_{L}\in{\cal C}(\Xi\otimes L,M)$, indexed by $L,M\in|{\cal C}|$: for every computation $f\in{\cal C}(L,M)$ there is an element $p\in{{\cal C}}^{\flat}(\Xi)$, called a program for $f$, such that $M$$f$$L$ $\displaystyle=$ $M$$u^{M}_{L}$$p$$L$ • partial evaluators $s_{MN}\in{{\cal C}}^{\flat}(\Xi\otimes M,\Xi)$, indexed by $M,N\in\lvert{\cal C}\rvert$, such that $\Xi$$M$$u_{N}^{L}$$s_{MN}$$N$$\Xi$$L$ $\displaystyle=$ $\Xi$$M$$u_{M\otimes N}^{L}$$N$$L$ Notation and intuition for the universal evaluators. The universal evaluators provide a monoidal view of the idea of a programming language. In theory of computability (e.g. [37]), this idea is formalized by the enumerations of computable functions. The programs thus boil down to numeric indices, and their executions are denoted using the Kleene’s brackets $\{-\}:{\mathbb{N}}\twoheadrightarrow{\sf Pfn}({\mathbb{N}},{\mathbb{N}})$, so that $\{p\}:{\mathbb{N}}\rightharpoonup{\mathbb{N}}$ represents the computation induced by the program $p$. It is thus natural to use the well-known notiation $\left\{{p}\right\}$ as the abbreviation for $u_{L}^{M}\circ(p\otimes L)$. The other way around, it is also convenient to have a notation for a program corresponding to a computation; so we generically write $\left\ulcorner{f}\right\urcorner$ for an arbitrary program that encodes a given computation $f$. In the monoidal computer formalism, these conventions thus mean $\psset{unit=3.414331pt}\psset{linewidth=1.024292pt, dotsep=3.414322pt, hatchwi% dth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=2.39003pt 2.5% , dotscale=11, fillcolor=black}\psset{arrowsize=3.414322pt 2.0, arrowlength=1.% 0, arrowinset=0.25, tbarsize=2.39003pt 5.0, bracketlength=0.15, rbracketlength% =0.15}\begin{pspicture}(0.0pt,0.0pt)(27.314636pt,46.947037pt)\rput(17.07164pt,% 46.947037pt){$$}{\psline{->}(17.07164pt,-28.168228pt)(17.07164pt,-4.267899pt)}% {\psset{}\pspolygon(6.828659pt,16.218063pt)(27.314636pt,16.218063pt)(27.314636% pt,-4.267899pt)(6.828659pt,-4.267899pt)}{\psline{->}(17.07164pt,16.218063pt)(1% 7.07164pt,40.118378pt)}\rput(17.07164pt,5.975067pt){$\left\{{p}\right\}$}\rput% (17.07164pt,-38.411209pt){$$}\end{pspicture}\ =\ \psset{unit=3.414331pt}\psset% {linewidth=1.024292pt, dotsep=3.414322pt, hatchwidth=0.3, hatchsep=1.5, shadow% size=1, dimen=middle}\psset{dotsize=2.39003pt 2.5, dotscale=11, fillcolor=% black}\psset{arrowsize=3.414322pt 2.0, arrowlength=1.0, arrowinset=0.25, tbars% ize=2.39003pt 5.0, bracketlength=0.15, rbracketlength=0.15}\begin{pspicture}(0% .0pt,0.0pt)(68.286606pt,46.947037pt)\rput(58.04361pt,46.947037pt){$$}{\psline{% ->}(17.07164pt,-21.339554pt)(17.07164pt,2.560745pt)}{\psset{}\pspolygon(6.8286% 59pt,16.218063pt)(68.286606pt,16.218063pt)(68.286606pt,-4.267899pt)(6.828659pt% ,-4.267899pt)}{\psline{->}(58.04361pt,16.218063pt)(58.04361pt,40.118378pt)}% \rput(54.629288pt,5.975067pt){$$}\rput(17.07164pt,-27.724365pt){$p$}{\psline{-% >}(58.04361pt,-28.168228pt)(58.04361pt,-4.267899pt)}\rput(58.04361pt,-38.41120% 9pt){$$}{\pspolygon(8.535812pt,-21.339554pt)(25.607468pt,-21.339554pt)(17.1057% 89pt,-40.562241pt)(8.535812pt,-21.339554pt)}{\pspolygon(12.803726pt,10.65271pt% )(21.339554pt,10.65271pt)(17.07164pt,2.116882pt)(12.803726pt,10.65271pt)}% \end{pspicture}\qquad\qquad\qquad\qquad\psset{unit=3.414331pt}\psset{linewidth% =1.024292pt, dotsep=3.414322pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, di% men=middle}\psset{dotsize=2.39003pt 2.5, dotscale=11, fillcolor=black}\psset{a% rrowsize=3.414322pt 2.0, arrowlength=1.0, arrowinset=0.25, tbarsize=2.39003pt % 5.0, bracketlength=0.15, rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(27% .314636pt,46.947037pt)\rput(17.07164pt,46.947037pt){$$}{\psline{->}(17.07164pt% ,-28.168228pt)(17.07164pt,-4.267899pt)}{\psset{}\pspolygon(6.828659pt,16.21806% 3pt)(27.314636pt,16.218063pt)(27.314636pt,-4.267899pt)(6.828659pt,-4.267899pt)% }{\psline{->}(17.07164pt,16.218063pt)(17.07164pt,40.118378pt)}\rput(17.07164pt% ,5.975067pt){$f$}\rput(17.07164pt,-38.411209pt){$$}\end{pspicture}\ =\ \psset{% unit=3.414331pt}\psset{linewidth=1.024292pt, dotsep=3.414322pt, hatchwidth=0.3% , hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=2.39003pt 2.5, dotsc% ale=11, fillcolor=black}\psset{arrowsize=3.414322pt 2.0, arrowlength=1.0, arro% winset=0.25, tbarsize=2.39003pt 5.0, bracketlength=0.15, rbracketlength=0.15}% \begin{pspicture}(0.0pt,0.0pt)(68.286606pt,46.947037pt)\rput(58.04361pt,46.947% 037pt){$$}{\psline{->}(17.07164pt,-21.339554pt)(17.07164pt,2.560745pt)}{\psset% {}\pspolygon(6.828659pt,16.218063pt)(68.286606pt,16.218063pt)(68.286606pt,-4.2% 67899pt)(6.828659pt,-4.267899pt)}{\psline{->}(58.04361pt,16.218063pt)(58.04361% pt,40.118378pt)}\rput(54.629288pt,5.975067pt){$$}\rput(17.07164pt,-27.724365pt% ){$\scriptstyle\ulcorner\!f\!\urcorner$}{\psline{->}(58.04361pt,-28.168228pt)(% 58.04361pt,-4.267899pt)}\rput(58.04361pt,-38.411209pt){$$}{\pspolygon(8.535812% pt,-21.339554pt)(25.607468pt,-21.339554pt)(17.105789pt,-40.562241pt)(8.535812% pt,-21.339554pt)}{\pspolygon(12.803726pt,10.65271pt)(21.339554pt,10.65271pt)(1% 7.07164pt,2.116882pt)(12.803726pt,10.65271pt)}\end{pspicture}$ With these notations, Eq. (11) becomes $\displaystyle\left\{{\left\ulcorner{f}\right\urcorner}\right\}$ $\displaystyle=$ $\displaystyle f$ The dual equation $\left\ulcorner{\left\{{p}\right\}}\right\urcorner=p$ is usually not satisfied. It characterizes the special family of computers which happen to be extensional in the strong sense that each computation corresponds to a unique program. An example of such a computer will be mentioned below. Convention. To simplify geometric reasoning, in diagrams we often omit any redundant labels and brackets, and even denote the program and the corresponding computation by the same name, whenever the distinction between the two is graphically obvious. Proposition 4.2 Let ${\cal C}$ be a symmetric monoidal category with data services, and such that every object $M\in|{\cal C}|$ is in the form $M=\Xi^{\otimes m}$ for some $m\geq 0$. A specification of the universal evaluators and of the partial evaluators as in Def. 4.1 is equivalent to a specification, for every $L,M\in\lvert{\cal C}\rvert$, of a family of surjections $\displaystyle\gamma^{LM}_{X}\ :\ {{\cal C}}^{\flat}(X,\Xi)$ $\displaystyle\twoheadrightarrow$ $\displaystyle{\cal C}(X\otimes L,M)$ natural in $X$. The correspondence of the families $\gamma^{LM}$ and the universal evaluators $u^{M}_{L}$ is one-to-one, but each such couple there may be different choices of the corresponding partial evaluators $s_{LN}$. Proof. Given a natural family of surjections (13), define – universal evaluators $u_{L}^{M}=\gamma_{\Xi}^{LM}({\rm id}_{\Xi})$ – partial evaluators $s_{MN}$ such that $\gamma^{NL}_{\Xi\otimes M}(s_{MN})=u^{L}_{M\otimes N}$ The partial evaluators are not unique, but they exist because each $\gamma^{NL}_{X}$ is surjective, so $u^{L}_{M\otimes N}$ must be in the image of $\gamma^{NL}_{\Xi\otimes M}$. The naturality of $\gamma^{LM}_{X}$ in $X$ implies that the following squares commute $\scriptstyle{{\cal C}}^{\flat}(\Xi,\Xi)$$\scriptstyle\scriptstyle{\cal C}(\Xi\otimes L,M)$$\scriptstyle{{\cal C}}^{\flat}(I,\Xi)$$\scriptstyle{\cal C}(L,M)$$\scriptstyle\gamma^{LM}_{\Xi}$$\scriptstyle\gamma^{LM}_{I}$$\scriptstyle-\circ p$$\scriptstyle-\circ(p\otimes L)$$\scriptstyle{{\cal C}}^{\flat}(\Xi,\Xi)$$\scriptstyle{{\cal C}}^{\flat}(\Xi\otimes M,\Xi)$$\scriptstyle{\cal C}(\Xi\otimes M\otimes N,L)$$\scriptstyle-\circ s_{MN}$$\scriptstyle-\circ(s_{MN}\otimes M)$$\scriptstyle\gamma^{NL}_{\Xi\otimes M}$$\scriptstyle\scriptstyle{\cal C}(\Xi\otimes N,L)$$\scriptstyle\gamma^{NL}_{\Xi}$ The commutativity of the right-hand square gives condition (12). The commutativity of the left-hand square means that $\gamma^{LM}_{I}(p)=u^{M}_{L}\circ(p\otimes L)$. Condition (11) thus follows from the assumption that $\gamma^{MN}_{I}$ is a surjection. The other way around, given a family of universal evaluators $u_{L}^{M}$, define $\displaystyle\gamma^{LM}_{X}(q)$ $\displaystyle=$ $\displaystyle u^{M}_{L}\circ(q\otimes L)$ This is easily seen to give a family natural for the functions in and out of $X$. To prove that $\gamma^{LM}_{X}$ is surjective for every $X\in|{\cal C}|$, we proceed by induction in $i$ where $X=\Xi^{\otimes i}$. Condition (11) says that the component $\gamma^{LM}_{I}$ is surjective, and thus gives the base case $i=0$. Condition (12) gives the inductive step. $\square$ Examples Computable partial functions and relations. In the standard model of monoidal computer, the data are represented as bitstrings, and the computations are the computable partial functions, as implemented, say, by deterministic Turing machines. More precisely, let $\Xi=\{0,1\}^{\ast}$ be the set of all finite binary strings. Let ${\cal C}$ be the category consisting of • objects: cartesian powers of $\{0,1\}^{\ast}$ • morphisms: computable partial functions. This is a subcategory of the category ${\sf Pfn}$ of all sets and all partial functions, so the monoidal structure and the data services are the same, since the copying, deleting and comparing operations are computable. Using nondeterministic Turing machines would lead to computable relations, and to the monoid computer contained in the category of sets and relations. The three parts of the definition of monoid computer correspond to three conceptual pillars of theory of computation: • The requirement that all types are the tensor powers of the universal data type says that all data are presented as tuples of bitstrings. • The universal evaluation operations $u_{M}^{N}$ correspond to the general purpose computers, or more formally to the universal Turing machines with $m$ input tapes and $n$ output tapes, where $M=\Xi^{\otimes m}$ and $N=\Xi^{\otimes n}$. • The partial evaluation operations $s_{MN}$ correspond to Kleene’s smn-functions, or to the partial evaluators used in programming. These ideas are discussed in detail in many computability theory textbooks and monographs, e.g. [37]. The natural surjection spelled out in Proposition 4.2 is a categorical view of the intensional enumerations of computable functions, which pervade the computability theory books and proofs. Scott’s domain theory tightens, in a sense, these intensional enumerations into an extensional isomorphism between a domain of programs and of a domain of the functions encoded by these programs, which leads us to the next example. Extensional monoidal computer. Consider a category of domains for denotational semantics, e.g. the category of continuous lattices $\sf CLat$, or of continuous partial orders $\sf Cpo$ [17, 2]. These categories are cartesian closed, and the cartesian structure gives a canonical comonoid structure $X\times X\xleftarrow{\delta}X\xrightarrow{{\scriptstyle\top}}1\!\!1$ on every $X$. For pointed domains, i.e. those with the least element, this structure extends to a full data service, with idempotent convolution. To form a monoid computer, we need a pointed reflexive domain $\Xi$. The reflexivity here implies that there is an isomorphism $\Xi\underset{v}{\overset{u}{\rightleftarrows}}\Xi^{\Xi}$. In other words, for every $f:\Xi\rightarrow\Xi$ there is $p=v(f)\in\Xi$ with $f=u(p)$. The extensional monoid computer is defined to be the full subcategory ${\cal C}$ spanned by the finite powers $\Xi^{m}$, $m\geq 0$, of a nontrivial reflexive object $\Xi$ in a category of domains with the bottom. The nontriviality assumption means that $\Xi$ contains the discrete set of natural numbers $\omega=\{0,1,2,\ldots\}\subseteq\Xi$. Now the assumptions that $\Xi^{\Xi}\cong\Xi$ and that $n\subseteq\Xi$ for every $n=\{0,1,\ldots,n-1\}$ together imply that for every $M=\Xi^{m}$ and $N=\Xi^{n}$, $m,n\geq 0$ there is a surjection $\displaystyle\Xi$ $\displaystyle\stackrel{{\scriptstyle u_{M}^{N}}}{{\twoheadrightarrow}}$ $\displaystyle N^{M}$ derived from • $\Xi^{M}=\Xi^{\left(\Xi^{m}\right)}\cong\Xi$, which is itself derived from $\Xi^{\Xi\times\Xi}\cong\left(\Xi^{\Xi}\right)^{\Xi}\cong\Xi^{\Xi}\cong\Xi$; • $N^{M}=\left(\Xi^{n}\right)^{M}\cong\left(\Xi^{M}\right)^{n}\cong\Xi^{n}% \twoheadrightarrow\Xi^{\Xi}\cong\Xi$, which lifts $n\hookrightarrow\Xi$. Checking that $u_{M}^{N}$ in (14) gives a universal evaluator is straightforward. The partial evaluators are constructed as in Prop.4.2. The extensionality means that every computation $f\in N^{M}$ is represented by a unique progam $p\in\Xi$. This is clear if we only look at the computations with a single input, as it is expressed by the fact that $u:\Xi\rightarrow\Xi^{\Xi}$ is an isomorphism. Capturing the computations with finitely many inputs and outputs requires data services, which complicate the picture, and make the universal evaluators $u_{M}^{N}:\Xi\rightarrow N^{M}$ into mere surjections. A closer inspection of the above construction of $u_{M}^{N}$ shows that it assigns a unique program to each computation of $m$ inputs and $n$ outputs, and maps the programs of other arities to the bottom. Quantum computer can be viewed as a monoidal computer in the category ${\sf Vec}_{\mathbb{C}}$ of complex vector spaces and linear operators, with the data services as described in Sec. 3. The universal data type is the 2-dimensional vector space ${\mathbb{C}}^{2}$, which plays the role of cogenerator, similar to the role of the 2-element set in the category ${\sf Rel}$. The universal and the partial evaluators are the evaluators of the Deutsch-Turing machines [14, 6]. The evaluators and their programs have classical descriptions, which in the framework of the monoidal computer formally means that they are basic data, as required by Definitions 3.2 and 4.1. On the other hand, the main feature of the quantum computer is that it processes mixed data, and that such processing can be used to execute many computational threads in parallel, with a low computational overhead. The gains from this feature will be captured in monoidal computers in terms of the space complexity. A physically more realistic view of quantum computation requires factoring out the irrelevant phases, and quotienting ${\mathbb{C}}^{2}$ to the data type of qubits. This leads to significantly more complicated notions of quantum operation, and of quantum computation [29]. However, the relevant features of these refined notions do not seem to be limited to their standard vector based realizations, as recognized already by von Neumann [36]. A categorical analysis of quantum computation allows distinguishing the essential structural components, while hiding the inessential implementation details of vector spaces [10], and even helps constructing the so-called toy models, used to study the dependencies between those components [38, 4, 11, 34]. There are thus many nonstandard quantum computers, some of them reducing the qubit computations all the way to boolean relations [32, 15]. Remark about compression The surjection ${{\cal C}}^{\flat}(\Xi)\xrightarrow{\gamma^{IM}_{I}}{\cal C}(M)$ allows compressing the data of type $M$ to programs that output these data when executed on empty input. This means that for every datum $I\xrightarrow{a}M$ there is a program $I\xrightarrow{p_{a}}\Xi$ such that $a=u_{I}^{M}\circ p_{a}$. Since we did not introduce a notion of size for the data yet, we do not have a way to say that $p_{a}$ is a succinct way to describe $a$. Indeed the program $p_{a}$ may say ”print $a$”, and be longer than $a$. Nevertheless, at a future step of this work, this compression mechanism will provide an abstract springboard into Kolmogorov complexity [40, 26], and a foundation for a monoidal view of randomized computation. Remark about the composition The bracket notation provides a convenient way to capture program composition with a minimal structural blowup. The surjectiveness $\{-\}=\gamma^{LM}_{I}:{{\cal C}}^{\flat}(\Xi)\twoheadrightarrow{\cal C}(L,M)$, $\{-\}=\gamma^{MN}_{I}:{{\cal C}}^{\flat}(\Xi)\twoheadrightarrow{\cal C}(M,N)$, and $\{-\}=\gamma^{LN}_{I}:{{\cal C}}^{\flat}(\Xi)\twoheadrightarrow{\cal C}(L,N)$ suggests that for any pair of programs $p,q\in{{\cal C}}^{\flat}(\Xi)$ such that $\{p\}\in{\cal C}(L,M)$ and $\{q\}\in{\cal C}(M,N)$, we can find some $r\in{{\cal C}}^{\flat}(\Xi)$ such that $\{r\}=\{q\}\circ\{p\}$. Similarly, for any pair of programs $s,t\in{{\cal C}}^{\flat}(\Xi)$ we can find a program $v\in{{\cal C}}^{\flat}(\Xi)$ such that $\{v\}=\{s\}\otimes\{t\}$. The type $\Xi$ in ${\cal C}$ could thus be coherently extended by partial monoid operations $-\|-$ and $-\,;-$ such that $\{p\,;q\}\ =\ \{q\}\circ\{p\}\qquad\qquad\{s\|t\}\ =\ \{s\}\otimes\{t\}$ In the standard computer models, this corresponds to introducing the composition operators in the programming language. One could indeed prove that any monoidal computer can be conservatively extended into a monoidal computer where the universal evaluators respect the internal program composition operations, used e.g. in [33]. This conservative extension, of course, contains exactly the same information as Def. 4.1. Since formalizing it does not seem to offer significant advantages for the present analyses, we shall for the moment keep program composition as syntactic sugar, and • generically denote by $p\,;q$ any program satisfying $\{p\,;q\}=\{q\}\circ\{p\}$, and • generically denote by $s\|t$ any program satisfying $\{s\|t\}=\{s\}\otimes\{t\}$. Arithmetic and logic in monoidal computer The simplest avenue towards an implementation of the basic logical and recursion theoretic constructions in monoidal computer seems to be by the way of interpreting the monoidal computations as $\lambda$-expressions. Monoidal computer and $\lambda$-calculus Viewed from through the lense of $\lambda$-calculus [3], the universal evaluators perform the function application operation, whereas the partial evaluators perform the function abstraction operation $\psset{unit=2.845276pt}\psset{linewidth=0.853577pt, dotsep=2.845261pt, hatchwi% dth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1.991684pt 2.% 5, dotscale=11, fillcolor=black}\psset{arrowsize=2.845261pt 2.0, arrowlength=1% .0, arrowinset=0.25, tbarsize=1.991684pt 5.0, bracketlength=0.15, rbracketleng% th=0.15}\begin{pspicture}(0.0pt,0.0pt)(62.254623pt,87.12233pt)\rput(8.877258pt% ,23.103638pt){$p$}{\psline{->}(8.877258pt,28.452744pt)(8.877258pt,49.792313pt)% }{\psline{->}(51.556381pt,28.452744pt)(51.556381pt,44.443192pt)}\rput(51.55638% 1pt,23.103638pt){$x$}{\psset{}\pspolygon(0.0pt,61.913193pt)(62.254623pt,61.913% 193pt)(62.254623pt,44.81308pt)(0.0pt,44.81308pt)}\rput(33.801865pt,53.377365pt% ){$px$}{\psline{->}(51.556381pt,62.254623pt)(51.556381pt,87.12233pt)}{% \pspolygon(5.349106pt,56.905502pt)(12.462296pt,56.905502pt)(8.877258pt,49.7923% 13pt)(5.349106pt,56.905502pt)}{\pspolygon(1.764069pt,28.452744pt)(15.990448pt,% 28.452744pt)(8.877258pt,12.462296pt)(1.764069pt,28.452744pt)}{\pspolygon(44.44% 3192pt,28.452744pt)(58.669571pt,28.452744pt)(51.584839pt,12.462296pt)(44.44319% 2pt,28.452744pt)}\end{pspicture}\qquad\qquad\qquad\psset{unit=2.845276pt}% \psset{linewidth=0.853577pt, dotsep=2.845261pt, hatchwidth=0.3, hatchsep=1.5, % shadowsize=1, dimen=middle}\psset{dotsize=1.991684pt 2.5, dotscale=11, fillcol% or=black}\psset{arrowsize=2.845261pt 2.0, arrowlength=1.0, arrowinset=0.25, tb% arsize=1.991684pt 5.0, bracketlength=0.15, rbracketlength=0.15}% \begin{pspicture}(0.0pt,0.0pt)(90.707382pt,108.461899pt)\rput(8.877258pt,10.66% 9769pt){$q$}{\psline{->}(8.877258pt,15.990448pt)(8.877258pt,39.122528pt)}{% \psline{->}(51.556381pt,15.990448pt)(51.556381pt,33.801865pt)}\rput(51.214951% pt,11.381088pt){$x$}{\psset{}\pspolygon(0.0pt,51.243408pt)(62.254623pt,51.2434% 08pt)(62.254623pt,34.143295pt)(0.0pt,34.143295pt)}\rput(37.330002pt,42.679123% pt){$\lambda y.\ q(x,y)$}{\psline{->}(80.00914pt,15.990448pt)(80.00914pt,69.36% 7813pt)}\rput(80.00914pt,10.669769pt){$y$}{\psline{->}(8.877258pt,46.235718pt)% (8.877258pt,74.688477pt)}{\psset{}\pspolygon(0.0pt,86.780899pt)(90.707382pt,86% .780899pt)(90.707382pt,69.709244pt)(0.0pt,69.709244pt)}{\psline{->}(80.00914pt% ,87.12233pt)(80.00914pt,108.461899pt)}{\pspolygon(44.443192pt,15.990448pt)(58.% 669571pt,15.990448pt)(51.556381pt,0.0pt)(44.443192pt,15.990448pt)}{\pspolygon(% 1.764069pt,15.990448pt)(15.990448pt,15.990448pt)(8.934158pt,0.0pt)(1.764069pt,% 15.990448pt)}{\pspolygon(72.89595pt,15.990448pt)(87.12233pt,15.990448pt)(80.06% 604pt,0.0pt)(72.89595pt,15.990448pt)}{\pspolygon(5.349106pt,81.801666pt)(12.46% 2296pt,81.801666pt)(8.877258pt,74.688477pt)(5.349106pt,81.801666pt)}{% \pspolygon(5.349106pt,46.235718pt)(12.462296pt,46.235718pt)(8.877258pt,39.1225% 28pt)(5.349106pt,46.235718pt)}\rput(48.028244pt,78.245071pt){$q(x,y)$}\end{pspicture}$ Together with the data services, these basic operations allow a sound interpretation of any $\lambda$-expression. Proposition 5.1 Every monoidal computer provides a model of nonextensional untyped $\lambda$-calculus. The proof is straightforward, provided that the notion of a model of $\lambda$-calculus is spelled out [3, I.5.2 and V]. The terms are interpreted as the elements of the universal data type $\Xi$. For the terms $t,s\in{\cal C}(\Xi)$, the abstraction $\lambda x.\ t$ is interpreted by $s_{I\Xi}\circ t$, whereas the application $ts$ is $u_{\Xi}^{\Xi}\circ(t\otimes s)$. The free variables can be interpreted in the polynomial extensions of monoidal computers, which are a special case of the constructions in [31]. We shall also use the polynomial extensions to capture randomized computation in monoidal computers. Representing numbers and truth values The external view of data computations. As the data in a monoidal computer are the elements of its data types, it will be convenient to to introduce the notation $\widehat{\Xi}={{\cal C}}^{\flat}(I,\Xi)\qquad\mbox{ and }\qquad\widehat{M}={{% \cal C}}^{\flat}\left(I,M\right)$ Note that the data service induces a bijection $\widehat{\Xi^{\otimes m}}\cong\widehat{\Xi}^{m}$, so that every computaion, viz. a morphism in the monoidal computer ${\cal C}$, induces a computable function ${tensy\vbox{\hbox spread 0.0pt{\hbox{\kern 3.29995pt\hbox{$\displaystyle% \penalty 1f\in{\cal C}\left(\Xi^{\otimes m},\Xi^{\otimes n}\right)$}}}\hbox{% \hbox{\kern 0.0pt\vrule height 0.25pt depth 0.25pt width 83.398727pt\hbox{}}}% \hbox{\kern 0.0pt\hbox{$\displaystyle\widehat{f}\in{\sf Set}(\widehat{\Xi}^{m}% ,\widehat{\Xi}^{n})$}}}}$ with $\widehat{f}(a)=f\circ a$. Externalizing the computations in this way, from a monidal computer ${\cal C}$ to the sets of data represented in it, we recover the usual notion of a computable function. Proposition 5.2 Every monoidal computer contains the representations of • truth values ${\mathbb{B}}=\{t\!t,f\!\!f\}\hookrightarrow\widehat{\Xi}$, and • natural numbers ${\mathbb{N}}=\{0,1,2,\ldots,n,\ldots\}\hookrightarrow\widehat{\Xi}$. The computations of the monoidal computer induce just the partial recursive functions on ${\mathbb{N}}$. The logical operations on ${\mathbb{B}}$ are also representable, thus supporting a full model of arithmetic. The representations of logical formulas and of partial recursive functions in untyped $\lambda$-calculus are developed in detail in [3, Ch. 6], or [23, Ch. 2]. The original Church’s representations $\displaystyle\left\ulcorner{t\!t}\right\urcorner\ =\ \lambda px.\ p$ $\displaystyle\left\ulcorner{f\!\!f}\right\urcorner\ =\ \left\ulcorner{0}\right% \urcorner\ =\ \lambda px.\ x$ $\displaystyle\left\ulcorner{i+1}\right\urcorner\ =\ \lambda px.\ p(ipx)$ seem the most convenient for our purposes. The basic logical operations are $\left\ulcorner{\neg}\right\urcorner\ =\lambda xyz.\ xzy\qquad\qquad\left% \ulcorner{\wedge}\right\urcorner\ =\ \lambda xy.\ xyx$ whereas the arithmetic operations are constructed using the recursion schema, which can be represented by applying a fixed point operator like the one in Prop. 6.1 to the recursion specifications expressed using the successor $\sigma$ and the ${\sf ifthenelse}$ operators $\left\ulcorner{\sigma}\right\urcorner\ =\ \lambda npx.\ p(npx)\qquad\qquad% \left\ulcorner{{\sf ifthenelse}}\right\urcorner\ =\ \lambda bxy.\ bxy$ The fact that the $\lambda$-constructions in the monoidal computer do not satisfy the $\eta$-rule $\lambda fx.\ fx=f$ invalidates the uniqueness claims of some constructions, but leaves the representability claims unchanged. Restating all this categorically, in terms of natural numbers object [24, 30], we have Proposition 5.3 In every monoidal computer, the universal data type $\Xi$ with the structure $I\xrightarrow{\ 0\ }\Xi\xleftarrow{\ \sigma\ }\Xi$ is a weak natural numbers object, in the sense that every pair $L\xrightarrow{g}M\xleftarrow{h}M$ induces a computation $\Xi\otimes L\xrightarrow{\llparenthesis{g,h}\rrparenthesis}M$, not necessarily unique, which makes the following diagram commute $\begin{split}\displaystyle\psset{unit=2.27622pt}\psset{linewidth=0.682861pt, d% otsep=2.276215pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}% \psset{dotsize=1.593353pt 2.5, dotscale=11, fillcolor=black}\psset{arrowsize=2% .276215pt 2.0, arrowlength=1.0, arrowinset=0.25, tbarsize=1.593353pt 5.0, brac% ketlength=0.15, rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(150.822357% pt,73.977158pt)\rput(11.381088pt,34.143295pt){$L$}\rput(79.667709pt,68.286606% pt){$\Xi\otimes L$}\rput(147.95433pt,68.286606pt){$\Xi\otimes L$}\rput(79.6677% 09pt,0.0pt){$M$}{\psline{->}(18.48291pt,38.422592pt)(65.44133pt,65.44133pt)}{% \psline{->}(19.916916pt,29.863998pt)(72.565903pt,2.845261pt)}{\psline{->}(132.% 29393pt,68.286606pt)(96.739365pt,68.286606pt)}{\psline{->}(140.852509pt,0.0pt)% (85.358261pt,0.0pt)}{\psset{linestyle=dashed, dash=2.276215pt 2.276215pt}% \psline{->}(79.667709pt,61.184799pt)(79.667709pt,9.969833pt)}{\psset{linestyle% =dashed, dash=2.276215pt 2.276215pt}\psline{->}(147.95433pt,61.184799pt)(147.9% 5433pt,9.969833pt)}\rput(147.95433pt,0.0pt){$M$}\rput{25.0}(36.988571pt,54.060% 226pt){$\scriptstyle 0\otimes L$}\rput{-25.0}(39.833847pt,14.226364pt){$% \scriptstyle g$}\rput(113.81102pt,73.977158pt){$\scriptstyle\sigma\otimes L$}% \rput(113.81102pt,-5.690536pt){$\scriptstyle h$}\rput[l](82.535751pt,35.55455% pt){$\scriptstyle\llparenthesis{g,h}\rrparenthesis$}\rput[l](150.822357pt,35.5% 5455pt){$\scriptstyle\llparenthesis{g,h}\rrparenthesis$}\end{pspicture}\end{split}$ Numeric monoidal computer Notation and terminology. In a monoidal computer, we use the term total elements to refer jointly to the numbers and the truth values, e.g. as represented in Eqn. (15). The set of all total elements is thus denoted by $\displaystyle{\mathbb{T}}$ $\displaystyle=$ $\displaystyle{\mathbb{B}}\cup{\mathbb{N}}\ \subseteq\ \widehat{\Xi}$ Definition 5.4 A computation $f\in{\cal C}\left(\Xi^{\otimes m},\Xi^{\otimes n}\right)$, is total if the induced function $\widehat{f}:\widehat{\Xi}^{m}\rightarrow\widehat{\Xi}^{n}$ maps total elements to total elements, i.e. restricts to a function $\widehat{f}_{\restriction}:{\mathbb{T}}^{m}\rightarrow{\mathbb{T}}^{n}$. It is total numeric if it maps numbers to numbers, i.e. restricts to a function $\widehat{f}_{\restriction}:{\mathbb{N}}^{m}\rightarrow{\mathbb{N}}^{n}$. Computations that are not total are called partial. Definition 5.5 A computation $\varphi\in{\cal C}\left(\Xi^{\otimes m},\Xi\right)$, is a predicate if its only total values are $t\!t$ or $f\!\!f$, i.e. if $\widehat{\varphi}\circ a\in{\mathbb{T}}\Longrightarrow\widehat{\varphi}\circ a% \in{\mathbb{B}}$. Definition 5.6 A monoidal computer is numeric if • every computation has a numeric program: for every computation $f:L\rightarrow M$ there is a number $p\in{\mathbb{N}}$ such that $f=u^{M}_{L}(p\otimes L)$ • the partial evaluations are total numeric functions $s_{LM}:{\mathbb{N}}\otimes L\rightarrow{\mathbb{N}}$ • there is a predicate $\downarrow_{\mathbb{N}}$ over $\Xi$ such that $\displaystyle\downarrow_{\mathbb{N}}x$ $\displaystyle=$ $\displaystyle\begin{cases}t\!t&\mbox{ if }x\in{\mathbb{N}}\\ f\!\!f&\mbox{ otherwise}\end{cases}$ Examples and non-examples. The classical and the quantum computers are numeric, whereas the extensional computer is not. Restriction. Henceforth we focus on numeric monoidal computers. The fixed point constructions In this section we illustrate the workings of the monoidal computer by spelling out the basic constructions of computability theory. Proposition 6.1 Every computation in a monoidal computer has a fixed point. Lemma 6.2 There is a computable program transformation $\Phi:\Xi\rightarrow\Xi$ which executes each program on itself, i.e. $\displaystyle\Phi\circ p$ $\displaystyle=$ $\displaystyle\{p\}\circ p$ Proof of Lemma 6.2. The transformation $\Xi$$\Phi$$\Xi$ $\displaystyle=$ $\Xi$$\Phi$$\Xi$ satisfies $\Phi$$p$ $\displaystyle=$ $\displaystyle\psset{unit=2.418484pt}\psset{linewidth=0.72554pt, dotsep=2.41847% 2pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1% .692932pt 2.5, dotscale=11, fillcolor=black}\psset{arrowsize=2.418472pt 2.0, a% rrowlength=1.0, arrowinset=0.25, tbarsize=1.692932pt 5.0, bracketlength=0.15, % rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(48.369675pt,45.346573pt){% \psline{->}(16.63916pt,4.546738pt)(16.63916pt,21.476135pt)}{\psset{}\pspolygon% (9.069305pt,31.440292pt)(48.369675pt,31.440292pt)(48.369675pt,16.929382pt)(9.0% 69305pt,16.929382pt)}{\psline{->}(42.323471pt,31.730499pt)(42.323471pt,45.3465% 73pt)}\rput(42.323471pt,24.18483pt){$$}{\psline{->}(42.323471pt,5.127182pt)(42% .323471pt,16.63916pt)}{\pspolygon(9.069305pt,4.546738pt)(48.369675pt,4.546738% pt)(36.277252pt,-7.54567pt)(21.161728pt,-7.54567pt)(9.069305pt,4.546738pt)}{% \psline{->}(28.731583pt,-16.63916pt)(28.731583pt,-7.54567pt)}\rput(28.731583pt% ,-1.499451pt){$$}\rput(28.731583pt,-22.685379pt){$p$}{\pspolygon(13.591873pt,2% 7.207947pt)(19.638092pt,27.207947pt)(16.63916pt,21.161728pt)(13.591873pt,27.20% 7947pt)}{\pspolygon(22.685379pt,-16.63916pt)(34.777802pt,-16.63916pt)(28.73158% 3pt,-30.231049pt)(22.685379pt,-16.63916pt)}\end{pspicture}\ \ =\ \ \psset{unit% =2.560748pt}\psset{linewidth=0.768219pt, dotsep=2.560745pt, hatchwidth=0.3, ha% tchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1.792511pt 2.5, dotscale% =11, fillcolor=black}\psset{arrowsize=2.560745pt 2.0, arrowlength=1.0, arrowin% set=0.25, tbarsize=1.792511pt 5.0, bracketlength=0.15, rbracketlength=0.15}% \begin{pspicture}(0.0pt,0.0pt)(51.214951pt,39.998871pt){\psline{->}(17.617935% pt,-3.200928pt)(17.617935pt,14.724289pt)}{\psset{}\pspolygon(9.602798pt,25.300% 186pt)(51.214951pt,25.300186pt)(51.214951pt,9.935699pt)(9.602798pt,9.935699pt)% }{\psline{->}(44.81308pt,25.607468pt)(44.81308pt,39.998871pt)}\rput(44.81308pt% ,17.617935pt){$$}{\psline{->}(44.81308pt,-2.560745pt)(44.81308pt,9.602798pt)}% \rput(17.617935pt,-9.602798pt){$p$}{\pspolygon(11.216064pt,-3.200928pt)(24.019% 806pt,-3.200928pt)(17.617935pt,-17.617935pt)(11.216064pt,-3.200928pt)}\rput(44% .81308pt,-9.602798pt){$p$}{\pspolygon(14.391403pt,20.793274pt)(20.793274pt,20.% 793274pt)(17.617935pt,14.391403pt)(14.391403pt,20.793274pt)}{\pspolygon(38.411% 209pt,-3.200928pt)(51.214951pt,-3.200928pt)(44.81308pt,-17.617935pt)(38.411209% pt,-3.200928pt)}\end{pspicture}\ \ =\ \ \psset{unit=2.560748pt}\psset{linewidt% h=0.768219pt, dotsep=2.560745pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, d% imen=middle}\psset{dotsize=1.792511pt 2.5, dotscale=11, fillcolor=black}\psset% {arrowsize=2.560745pt 2.0, arrowlength=1.0, arrowinset=0.25, tbarsize=1.792511% pt 5.0, bracketlength=0.15, rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)% (20.485977pt,41.612152pt){\psline{->}(12.803726pt,-3.200928pt)(12.803726pt,11.% 216064pt)}{\psset{}\pspolygon(5.12149pt,26.580551pt)(20.485977pt,26.580551pt)(% 20.485977pt,11.216064pt)(5.12149pt,11.216064pt)}{\psline{->}(12.803726pt,26.58% 0551pt)(12.803726pt,41.612152pt)}\rput(12.803726pt,18.898315pt){$p$}\rput(12.8% 03726pt,-9.602798pt){$p$}{\pspolygon(6.401855pt,-3.200928pt)(19.205597pt,-3.20% 0928pt)(12.803726pt,-17.617935pt)(6.401855pt,-3.200928pt)}\end{pspicture}$ because the programs $p$ are basic data, and thus satisfy $\delta\circ p=p\otimes p$. $\square$ Remark. Note that the second step of the above proof essentially depends on the stipulation in Def. 4.1, that programs are basic data, and thus copiable by the data service. Proof of Prop. 6.1. The fixed point of an arbitrary $p\in{\cal C}(\Xi)$ is $\Phi$$\Phi\,;p$ $\displaystyle=$ $\displaystyle\psset{unit=2.703012pt}\psset{linewidth=0.810898pt, dotsep=2.7030% 03pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=% 1.892105pt 2.5, dotscale=11, fillcolor=black}\psset{arrowsize=2.703003pt 2.0, % arrowlength=1.0, arrowinset=0.25, tbarsize=1.892105pt 5.0, bracketlength=0.15,% rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(30.408875pt,43.923935pt){% \psline{->}(13.515045pt,-3.378754pt)(13.515045pt,11.839188pt)}{\psset{}% \pspolygon(-1.675858pt,28.381622pt)(28.705978pt,28.381622pt)(28.705978pt,12.16% 3544pt)(-1.675858pt,12.163544pt)}{\psline{->}(13.515045pt,28.705978pt)(13.5150% 45pt,43.923935pt)}\rput(13.515045pt,19.948227pt){$\Phi\,;p$}\rput(13.515045pt,% -10.136292pt){$\Phi\,;p$}{\pspolygon(-1.675858pt,-3.378754pt)(30.408875pt,-3.3% 78754pt)(13.515045pt,-23.651352pt)(-1.675858pt,-3.378754pt)}\end{pspicture}\ % \ =\ \ \psset{unit=2.703012pt}\psset{linewidth=0.810898pt, dotsep=2.703003pt, % hatchwidth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1.8921% 05pt 2.5, dotscale=11, fillcolor=black}\psset{arrowsize=2.703003pt 2.0, arrowl% ength=1.0, arrowinset=0.25, tbarsize=1.892105pt 5.0, bracketlength=0.15, rbrac% ketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(30.408875pt,76.008682pt){\psline% {->}(13.515045pt,-3.378754pt)(13.515045pt,11.839188pt)}{\psset{}\pspolygon(-1.% 675858pt,28.381622pt)(28.705978pt,28.381622pt)(28.705978pt,12.163544pt)(-1.675% 858pt,12.163544pt)}{\psline{->}(13.515045pt,28.705978pt)(13.515045pt,43.923935% pt)}\rput(13.515045pt,19.948227pt){$\Phi$}\rput(13.515045pt,-10.136292pt){$% \Phi\,;p$}{\pspolygon(-1.675858pt,-3.378754pt)(30.408875pt,-3.378754pt)(13.515% 045pt,-23.651352pt)(-1.675858pt,-3.378754pt)}{\psset{}\pspolygon(-1.675858pt,6% 0.493393pt)(28.705978pt,60.493393pt)(28.705978pt,44.27533pt)(-1.675858pt,44.27% 533pt)}{\psline{->}(13.515045pt,60.817764pt)(13.515045pt,76.008682pt)}\rput(13% .515045pt,52.384369pt){$p$}\end{pspicture}$ where $\Phi\,;p$ denotes any program such that $\{\Phi\,;p\}=\{p\}\circ\{\Phi\}$. $\square$ Corollary 6.3 Every nontrivial numeric computer contains partial computations. Its universal data type always contains non-numeric values. Proof. Consider the successor operation $\sigma=\lambda npx.\ p(npx)$ and its fixed point $\bot=\{\Phi\}(\Phi\,;\sigma)$. Since the soundness of Church’s numeral representation [3, Sec. 6.4] implies that $\sigma n\neq n$ holds for all $n\in{\mathbb{N}}$, it follows that $\bot\not\in{\mathbb{N}}$. On the other hand, since the computer is assumed to be numeric, we can choose the program $\Phi\,;\sigma\in{\mathbb{N}}$. Since $\{\Phi\}(\Phi\,;\sigma)=\bot$, the computation $\{\Phi\}$ maps an element of ${\mathbb{N}}$ outside ${\mathbb{N}}$, and is therefore not total. $\square$ Kleene’s Second Recursion Theorem This theorem is undoubtedly one of the stepping stones into computability theory [28]. It says that every total computation $\widehat{t}:{\mathbb{N}}\rightarrow{\mathbb{N}}$, viewed as a program transformation, has a fixed program1Note that there are many total functions which do not have any fixed numbers: e.g. the successor function satisfies $\sigma(n)\neq n$ for all $n\in{\mathbb{N}}$. $p_{t}\in{\mathbb{N}}$, which encodes the same computable function as its $t$-image, i.e. $\displaystyle\{p_{t}\}$ $\displaystyle=$ $\displaystyle\left\{t(p_{t})\right\}$ Proposition 7.1 In any numeric monoidal computer ${\cal C}$, for every computation $t:\Xi\rightarrow\Xi$, which induces a total function $\widehat{t}:{\mathbb{N}}\rightarrow{\mathbb{N}}$, and for any two types $L,M\in|{\cal C}|$ there is a program $p_{t}\in{\mathbb{N}}$ which evaluates to the same $L\rightarrow M$ computation like $t\circ p_{t}$, i.e. $\displaystyle u^{M}_{L}\circ(p\otimes L)$ $\displaystyle=$ $\displaystyle u^{M}_{L}\circ(tp_{t}\otimes L)$ Proof. Define $\psset{unit=2.703012pt}\psset{linewidth=0.810898pt, dotsep=2.703003pt, hatchwi% dth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1.892105pt 2.% 5, dotscale=11, fillcolor=black}\psset{arrowsize=2.703003pt 2.0, arrowlength=1% .0, arrowinset=0.25, tbarsize=1.892105pt 5.0, bracketlength=0.15, rbracketleng% th=0.15}\begin{pspicture}(0.0pt,0.0pt)(32.111771pt,37.166412pt)\rput(3.378754% pt,-28.705978pt){$\Xi$}{\psline{->}(3.378754pt,-23.651352pt)(3.378754pt,-4.730% 27pt)}{\psset{}\pspolygon(-5.08165pt,11.487793pt)(32.111771pt,11.487793pt)(32.% 111771pt,-4.73027pt)(-5.08165pt,-4.73027pt)}{\psline{->}(13.515045pt,11.839188% pt)(13.515045pt,32.436127pt)}\rput(13.515045pt,3.378754pt){$\Gamma$}{\psline{-% >}(21.948456pt,-23.651352pt)(21.948456pt,-4.73027pt)}\rput(21.948456pt,-28.705% 978pt){$L$}\rput(13.515045pt,37.166412pt){$M$}\end{pspicture}\ =\ \psset{unit=% 2.703012pt}\psset{linewidth=0.810898pt, dotsep=2.703003pt, hatchwidth=0.3, hat% chsep=1.5, shadowsize=1, dimen=middle}\psset{dotsize=1.892105pt 2.5, dotscale=% 11, fillcolor=black}\psset{arrowsize=2.703003pt 2.0, arrowlength=1.0, arrowins% et=0.25, tbarsize=1.892105pt 5.0, bracketlength=0.15, rbracketlength=0.15}% \begin{pspicture}(0.0pt,0.0pt)(64.196518pt,59.141891pt){\psline{->}(18.59671pt% ,-1.675858pt)(18.59671pt,17.245209pt)}{\psset{}\pspolygon(10.136292pt,28.38162% 2pt)(54.060226pt,28.381622pt)(54.060226pt,12.163544pt)(10.136292pt,12.163544pt% )}{\psline{->}(45.626831pt,28.705978pt)(45.626831pt,52.384369pt)}\rput(45.6268% 31pt,20.272583pt){$$}\rput[Br](62.493622pt,-23.651352pt){$\Gamma$}{\psline{->}% (45.626831pt,-42.221039pt)(45.626831pt,11.839188pt)}{\psline{->}(18.59671pt,-4% 2.275101pt)(18.59671pt,-18.59671pt)}\rput(18.59671pt,-10.136292pt){$\Phi$}{% \psset{}\pspolygon(0.0pt,38.869308pt)(64.196518pt,38.869308pt)(64.196518pt,-25% .678604pt)(0.0pt,-25.678604pt)}\rput(18.59671pt,-47.302704pt){$\Xi$}{\psset{}% \pspolygon(10.136292pt,-2.027252pt)(27.030106pt,-2.027252pt)(27.030106pt,-18.2% 45316pt)(10.136292pt,-18.245316pt)}\rput(45.626831pt,-47.302704pt){$L$}\rput(4% 5.626831pt,59.141891pt){$M$}{\pspolygon(15.190918pt,23.651352pt)(21.948456pt,2% 3.651352pt)(18.59671pt,16.893814pt)(15.190918pt,23.651352pt)}\end{pspicture}% \qquad\qquad\qquad\psset{unit=2.703012pt}\psset{linewidth=0.810898pt, dotsep=2% .703003pt, hatchwidth=0.3, hatchsep=1.5, shadowsize=1, dimen=middle}\psset{dot% size=1.892105pt 2.5, dotscale=11, fillcolor=black}\psset{arrowsize=2.703003pt % 2.0, arrowlength=1.0, arrowinset=0.25, tbarsize=1.892105pt 5.0, bracketlength=% 0.15, rbracketlength=0.15}\begin{pspicture}(0.0pt,0.0pt)(32.111771pt,52.384369% pt){\psset{}\pspolygon(0.0pt,24.489273pt)(32.111771pt,24.489273pt)(32.111771pt% ,-4.21669pt)(0.0pt,-4.21669pt)}{\psline{->}(8.433395pt,25.354248pt)(8.433395pt% ,45.626831pt)}{\psline{->}(25.354248pt,-27.030106pt)(25.354248pt,-5.054626pt)}% \rput(15.190918pt,10.136292pt){$\Upsilon$}\rput(25.354248pt,-33.787643pt){$\Xi% $}\rput(8.433395pt,52.384369pt){$\Xi$}\end{pspicture}\ =\ \psset{unit=2.703012% pt}\psset{linewidth=0.810898pt, dotsep=2.703003pt, hatchwidth=0.3, hatchsep=1.% 5, shadowsize=1, dimen=middle}\psset{dotsize=1.892105pt 2.5, dotscale=11, fill% color=black}\psset{arrowsize=2.703003pt 2.0, arrowlength=1.0, arrowinset=0.25,% tbarsize=1.892105pt 5.0, bracketlength=0.15, rbracketlength=0.15}% \begin{pspicture}(0.0pt,0.0pt)(64.196518pt,59.141891pt){\psline{->}(18.59671pt% ,-1.675858pt)(18.59671pt,17.245209pt)}{\psset{}\pspolygon(10.136292pt,28.38162% 2pt)(54.060226pt,28.381622pt)(54.060226pt,12.163544pt)(10.136292pt,12.163544pt% )}{\psline{->}(18.59671pt,23.651352pt)(18.59671pt,52.384369pt)}\rput(43.923935% pt,20.272583pt){$s_{\Xi L}$}\rput[Br](62.493622pt,-23.651352pt){$\Upsilon$}{% \psline{->}(45.626831pt,-42.221039pt)(45.626831pt,11.839188pt)}{\psset{}% \pspolygon(0.0pt,38.869308pt)(64.196518pt,38.869308pt)(64.196518pt,-25.678604% pt)(0.0pt,-25.678604pt)}\rput(45.626831pt,-47.302704pt){$\Xi$}\rput(18.59671pt% ,59.141891pt){$\Xi$}\rput(18.59671pt,-6.757523pt){$\Gamma$}{\pspolygon(15.1909% 18pt,23.651352pt)(21.948456pt,23.651352pt)(18.59671pt,16.893814pt)(15.190918pt% ,23.651352pt)}{\pspolygon(11.839188pt,-1.675858pt)(25.354248pt,-1.675858pt)(18% .59671pt,-16.893814pt)(11.839188pt,-1.675858pt)}\end{pspicture}$ The program transformations showing that the program $p_{t}=\{\Upsilon\}(\Upsilon\,;t)$ is the claimed fixed point are displayed on the following diagram
Definition 4.1 A (basic) monidal computer is a data service ${\cal C}$ which has: • a universal data type $\Xi$: it generates all types as its tensor powers, i.e. for every $M\in\lvert{\cal C}\rvert$ there is $m\geq 0$ such that $M=\Xi^{\otimes m}$ • universal evaluators $u^{M}_{L}\in{\cal C}(\Xi\otimes L,M)$, indexed by $L,M\in|{\cal C}|$: for every computation $f\in{\cal C}(L,M)$ there is an element $p\in{{\cal C}}^{\flat}(\Xi)$, called a program for $f$, such that $M$$f$$L$ $\displaystyle=$ $M$$u^{M}_{L}$$p$$L$ • partial evaluators $s_{MN}\in{{\cal C}}^{\flat}(\Xi\otimes M,\Xi)$, indexed by $M,N\in\lvert{\cal C}\rvert$, such that $\Xi$$M$$u_{N}^{L}$$s_{MN}$$N$$\Xi$$L$ $\displaystyle=$ $\Xi$$M$$u_{M\otimes N}^{L}$$N$$L$
Definition 3.6 A morphism $f\in{\cal C}(A,B)$ is an (abstract) relation with respect to some given data service on $A$ and $B$ if $f\star f=f$.
Definition 3.3 The pure morphisms, or (basic) functions with respect to data services $(A,{\scriptstyle\top}_{A},\delta_{A},\varrho_{A})$ and $(B,{\scriptstyle\top}_{B},\delta_{B},\varrho_{B})$ are the morphisms $f\in{\cal C}(A,B)$ that correspond to comonoid homomorphisms $f:A\rightarrow B$. The set of pure morphisms with respect the given data services on $A$ and $B$ are written ${{\cal C}}^{\flat}(A,B)$. This is the basis of ${\cal C}(A,B)$. The morphisms that are not pure are called mixed.
Definition 5.5 A computation $\varphi\in{\cal C}\left(\Xi^{\otimes m},\Xi\right)$, is a predicate if its only total values are $t\!t$ or $f\!\!f$, i.e. if $\widehat{\varphi}\circ a\in{\mathbb{T}}\Longrightarrow\widehat{\varphi}\circ a% \in{\mathbb{B}}$.
Definition 3.5 Any data service on $A$ induces the operations • convolution $\star\ :\ {\cal C}(A,B)\times{\cal C}(A,B)\longrightarrow{\cal C}(A,B)$ with $\displaystyle f\star g$ $\displaystyle=$ $\displaystyle\varrho_{B}\circ(f\otimes g)\circ\delta_{A}$ • norm $\lvert-\rvert\ :\ {\cal C}(A)\longrightarrow{\cal C}(I)$ with $\displaystyle\lvert a\rvert$ $\displaystyle=$ $\displaystyle{\scriptstyle\top}_{A}\circ a$ • inner product $<-|->\ :\ {\cal C}(A)\times{\cal C}(A)\longrightarrow{\cal C}(I)$ with $\displaystyle<a|b>$ $\displaystyle=$ $\displaystyle{\scriptstyle\top}_{A}\circ\varrho_{A}\circ(a\otimes b)$ $f$$g$$A$$B$ Figure 6: Convolution $a$\closepath\closepath Figure 7: Norm $a$$b$\closepath\closepath\closepath Figure 8: Inner product
Definition 5.4 A computation $f\in{\cal C}\left(\Xi^{\otimes m},\Xi^{\otimes n}\right)$, is total if the induced function $\widehat{f}:\widehat{\Xi}^{m}\rightarrow\widehat{\Xi}^{n}$ maps total elements to total elements, i.e. restricts to a function $\widehat{f}_{\restriction}:{\mathbb{T}}^{m}\rightarrow{\mathbb{T}}^{n}$. It is total numeric if it maps numbers to numbers, i.e. restricts to a function $\widehat{f}_{\restriction}:{\mathbb{N}}^{m}\rightarrow{\mathbb{N}}^{n}$. Computations that are not total are called partial.
Definition 3.2 A basic data value, or an (abstract) element with respect to a data service $(A,{\scriptstyle\top},\delta,\varrho)$ is a data value $a\in{\cal C}(A)$ that can be copied and deleted: it corresponds to a comonoid homomorphism $a:I\rightarrow A$. ${{\cal C}}^{\flat}(A,{\scriptstyle\top},\delta,\varrho)$ denotes the set of basic data values with respect to the data service $(A,{\scriptstyle\top},\delta,\varrho)$ in ${\cal C}$. It is abbreviated to ${{\cal C}}^{\flat}(A)$ whenever the confusion is unlikely. This is the basis of ${\cal C}(A)$. The data values that are not basic are called mixed.
Definition 3.9 A data value $a\in{\cal C}(A)$ is normal if $<a|a>={\rm id}_{I}$. Data values $a,b\in{\cal C}(A)$ are orthogonal if $<a|b>^{2}=<a|b>$. A set $S\subseteq{\cal C}(A)$ is orthonormal if all of its elements are normal and any pair is orthogonal.
Definition 5.6 A monoidal computer is numeric if • every computation has a numeric program: for every computation $f:L\rightarrow M$ there is a number $p\in{\mathbb{N}}$ such that $f=u^{M}_{L}(p\otimes L)$ • the partial evaluations are total numeric functions $s_{LM}:{\mathbb{N}}\otimes L\rightarrow{\mathbb{N}}$ • there is a predicate $\downarrow_{\mathbb{N}}$ over $\Xi$ such that $\displaystyle\downarrow_{\mathbb{N}}x$ $\displaystyle=$ $\displaystyle\begin{cases}t\!t&\mbox{ if }x\in{\mathbb{N}}\\ f\!\!f&\mbox{ otherwise}\end{cases}$
Definition 3.1 A generalized differential restriction category is a Cartesian restriction category with: • for each object $X$, a total commutative monoid $L(X)=(L_{0}(X),+_{X},0_{X})$, satisfying $L(L_{0}(X))=L(X)\mbox{ and }L(X\times Y)=L(X)\times L(Y),$ • for each map $f:X\>\hbox{\raise 0.0pt\hbox{\kern 3.749943pt\hbox{\ignorespaces\ignorespaces% \ignorespaces\ignorespaces\ignorespaces{}\ignorespaces{\hbox{\kern 0.0pt\vrule w% idth -3.749943pt depth 0.0pt height 0.0pt}}\ignorespaces\ignorespaces{\hbox{% \kern 4.5pt\raise 0.0pt\hbox{{}\hbox{\kern 0.0pt\raise-1.999947pt\hbox{\hbox{% \kern 3.0pt\hbox{\hbox{\kern 0.0pt\raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3% .0pt}}}}}}\ignorespaces\ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}% \hbox{\kern 0.0pt\raise-1.999947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0% pt\raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces{\hbox{% \kern 11.250057pt\raise 0.0pt\hbox{h\hbox{\xyatipfont\char 47\xybtipfont\char 4% 7}\hbox{\kern 0.0pt\raise 0.0ptC}}}}\ignorespaces{\hbox{\kern 3.749943pt\vrule w% idth 7.500114pt depth 0.0pt height 0.0pt}}{\hbox{\kern 18.749943pt\vrule width% -3.749943pt depth 0.0pt height 0.0pt}}\ignorespaces}}}\>Y$, a map $D[f]:L_{0}(X)\times X\>\hbox{\raise 0.0pt\hbox{\kern 3.749943pt\hbox{% \ignorespaces\ignorespaces\ignorespaces\ignorespaces\ignorespaces{}% \ignorespaces{\hbox{\kern 0.0pt\vrule width -3.749943pt depth 0.0pt height 0.0% pt}}\ignorespaces\ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}\hbox{% \kern 0.0pt\raise-1.999947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0pt% \raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces% \ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}\hbox{\kern 0.0pt\raise-1.9% 99947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0pt\raise 0.0pt\hbox{$% \scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces{\hbox{\kern 11.250057pt\raise 0% .0pt\hbox{h\hbox{\xyatipfont\char 47\xybtipfont\char 47}\hbox{\kern 0.0pt% \raise 0.0ptC}}}}\ignorespaces{\hbox{\kern 3.749943pt\vrule width 7.500114pt d% epth 0.0pt height 0.0pt}}{\hbox{\kern 18.749943pt\vrule width -3.749943pt dept% h 0.0pt height 0.0pt}}\ignorespaces}}}\>L_{0}(Y)$ such that: [DR.1] $D[+_{X}]=\pi_{0}+_{X}$ and $D[0_{X}]=\pi_{0}0_{X}$; [DR.2] $\langle a+b,c\rangle D[f]=\langle a,b\rangle D[f]+\langle b,c\rangle D[f]$ and $\langle 0,a\rangle D[f]=\overline{af}0$; [DR.3] $D[\pi_{0}]=\pi_{0}\pi_{0}$, and $D[\pi_{1}]=\pi_{0}\pi_{1}$; [DR.4] $D[\langle f,g\rangle]=\langle D[f],D[g]\rangle$; [DR.5] $D[fg]=\langle D[f],\pi_{1}f\rangle D[g]$; [DR.6] $\langle\langle a,0\rangle,\langle c,d\rangle\rangle D[D[f]]=\overline{c}% \langle a,d\rangle D[f]$; [DR.7] $\langle\langle 0,b\rangle,\langle c,d\rangle\rangle D[D[f]]=\langle\langle 0,c% \rangle,\langle b,d\rangle\rangle D[D[f]]$; [DR.8] $D[\overline{f}]=(1\times\overline{f})\pi_{0}=\overline{\pi_{1}f}\,\pi_{0}$; [DR.9] $\overline{D[f]}=1\times\overline{f}=\overline{\pi_{1}f}\,$.
Definition 2.8 let cMon denote the endofunctor on cartCat which sends a category $\mathbb{X}$ to its category of commutative monoids and additive maps between them (with its obvious product struture).
Definition 2.1 A generalized Cartesian differential category consists of a Cartesian category $\mathbb{X}$ with: • for each object $X$, a commutative monoid $L(X)=(L_{0}(X),+_{X},0_{X})$, satisfying $L(L_{0}(X))=L(X)\mbox{ and }L(X\times Y)=L(X)\times L(Y),$ • for each map $f:X\>\hbox{\raise 0.0pt\hbox{\kern 3.749943pt\hbox{\ignorespaces\ignorespaces% \ignorespaces\ignorespaces\ignorespaces{}\ignorespaces{\hbox{\kern 0.0pt\vrule w% idth -3.749943pt depth 0.0pt height 0.0pt}}\ignorespaces\ignorespaces{\hbox{% \kern 4.5pt\raise 0.0pt\hbox{{}\hbox{\kern 0.0pt\raise-1.999947pt\hbox{\hbox{% \kern 3.0pt\hbox{\hbox{\kern 0.0pt\raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3% .0pt}}}}}}\ignorespaces\ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}% \hbox{\kern 0.0pt\raise-1.999947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0% pt\raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces{\hbox{% \kern 11.250057pt\raise 0.0pt\hbox{h\hbox{\xyatipfont\char 47\xybtipfont\char 4% 7}\hbox{\kern 0.0pt\raise 0.0ptC}}}}\ignorespaces{\hbox{\kern 3.749943pt\vrule w% idth 7.500114pt depth 0.0pt height 0.0pt}}{\hbox{\kern 18.749943pt\vrule width% -3.749943pt depth 0.0pt height 0.0pt}}\ignorespaces}}}\>Y$, a map $D[f]:L_{0}(X)\times X\>\hbox{\raise 0.0pt\hbox{\kern 3.749943pt\hbox{% \ignorespaces\ignorespaces\ignorespaces\ignorespaces\ignorespaces{}% \ignorespaces{\hbox{\kern 0.0pt\vrule width -3.749943pt depth 0.0pt height 0.0% pt}}\ignorespaces\ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}\hbox{% \kern 0.0pt\raise-1.999947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0pt% \raise 0.0pt\hbox{$\scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces% \ignorespaces{\hbox{\kern 4.5pt\raise 0.0pt\hbox{{}\hbox{\kern 0.0pt\raise-1.9% 99947pt\hbox{\hbox{\kern 3.0pt\hbox{\hbox{\kern 0.0pt\raise 0.0pt\hbox{$% \scriptstyle{}$}}}\kern 3.0pt}}}}}}\ignorespaces{\hbox{\kern 11.250057pt\raise 0% .0pt\hbox{h\hbox{\xyatipfont\char 47\xybtipfont\char 47}\hbox{\kern 0.0pt% \raise 0.0ptC}}}}\ignorespaces{\hbox{\kern 3.749943pt\vrule width 7.500114pt d% epth 0.0pt height 0.0pt}}{\hbox{\kern 18.749943pt\vrule width -3.749943pt dept% h 0.0pt height 0.0pt}}\ignorespaces}}}\>L_{0}(Y)$ such that: [CD.1] $D(+_{X})=\pi_{0}+_{X},D(0_{X})=\pi_{0}0_{X}$, [CD.2] $\langle a+b,c\rangle D[f]=\langle a,b\rangle D[f]+\langle b,c\rangle D[f]$ and $\langle 0,a\rangle D[f]=0$; [CD.3] $D[\pi_{0}]=\pi_{0}\pi_{0}$, and $D[\pi_{1}]=\pi_{0}\pi_{1}$; [CD.4] $D[\langle f,g\rangle]=\langle D[f],D[g]\rangle$; [CD.5] $D[fg]=\langle D[f],\pi_{1}f\rangle D[g]$; [CD.6] $\langle\langle a,0\rangle,\langle c,d\rangle\rangle D[D[f]]=\langle a,d\rangle D% [f]$; [CD.7] $\langle\langle 0,b\rangle,\langle c,d\rangle\rangle D[D[f]]=\langle\langle 0,c% \rangle,\langle b,d\rangle\rangle D[D[f]]$;
